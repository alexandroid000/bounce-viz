\documentclass[]{styles/svproc}  % Comment this line out

%\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
%\overrideIEEEmargins

\usepackage{amsmath}    % need for subequations
\usepackage{amssymb}
\usepackage{graphicx}   % need for figures
\usepackage{color}      % use if color is used in text
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{url}
\usepackage{bm}
\usepackage{tikz}
\usepackage[outdir=./figures/]{epstopdf}
\def\UrlFont{\rmfamily}


% bounce transition graph
% visibility event graph
% bounce visibility diagram/graph

% synthesis of paths with high-level dynamical properties from simple
% compliant environmental interactions

% skeptical questions:

% - what if the robot starts very near to a boundary of equivalence classes?

% Using Visibility Equivalence Classes for High-Level Dynamical Path Synthesis

% Minimal (Complexity | Attention) Path Synthesis with Dynamical Specifications

%\title{Path Synthesis from Dynamical Specifications \\ for Blind Mobile Robots in Polygons}

%
%
%
%%%% list of authors for the TOC (use if author list has to be modified)
%\tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%Craig Chambers, Kim B. Bruce, and Elisa Bertino}
%

\begin{document}
\mainmatter              % start of a contribution


% A Toolbox for
\title{A Visibility-Based Approach to Computing Nondeterministic Bouncing
Strategies}

\titlerunning{Nondeterministic Bouncing Strategies}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
\author{Alexandra Q. Nilles\inst{1} \and Yingying Ren\inst{1} \and Israel
Becerra\inst{1} \and Steven M. LaValle\inst{1}% <-this % stops a space
\thanks{
{test}
}
}
\institute{}
\authorrunning{A. Nilles, Y. Ren, I. Becerra, S. M. LaValle} % abbreviated author list (for running head)
%\thanks{This work was partially supported by National Science Foundation (award numbers ).}
%\email{I.Ekeland@princeton.edu},\\ WWW home page:
%\texttt{http://users/\homedir iekeland/web/welcome.html}
%\and
%Universit\'{e} de Paris-Sud,
%Laboratoire d'Analyse Num\'{e}rique, B\^{a}timent 425,\\
%F-91405 Orsay Cedex, France}


\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Inspired by motion patterns of some commercially available mobile robots, we investigate the power of robots that 
move forward in straight lines
until colliding with an environment boundary, at which point they can rotate in
place and move forward again; we visualize this as the robot ``bouncing'' off
boundaries. Different boundary interaction laws can be
defined for such robots, such as one that orients the robot relative to its
heading prior to collision, or relative to the normal of the boundary. We introduce a new data structure, the {\em bounce visibility graph}, which is generated 
from a polygonal environment definition and constraints on the robot's bouncing 
strategy. The bounce visibility graph can be queried to determine the feasibility 
of path-based tasks such as navigation and patrolling. If the task is feasible, then this
approach synthesizes a controller and calculates the maximum allowable 
uncertainty in the robot's actuation, thereby providing design constraints for different 
environments and tasks.
\end{abstract}


\section{Introduction}

Mobile robots have rolled smoothly into our everyday lives, and can now be
spotted vacuuming our floors, cleaning our pools, mowing our grass, and moving
goods in our warehouses. These tasks require that the robot's path achieve certain properties; for example, a 
vacuuming robot should cover the whole space while not visiting 
any particular area more frequently than others. A robot that is monitoring
humidity or temperature in a warehouse may be
required to follow a repeatable path so that data can be easily compared 
over time. In these examples and more, the strategies for controlling the robot's
path may be decoupled from the specific tasks, and we envision building a
library of useful high-level path controllers based on desired dynamical system
properties.

Current algorithmic approaches to these tasks take two flavors: 1)
maximizing the information available to the robot though high-fidelity sensors
and map-generating algorithms such as SLAM, or 2) minimizing the information needed
by the robot, such as the largely random navigation strategies of the early
iRobot vacuum models. The first approach is very powerful and well-suited to 
dynamic environments, but also
resource-intensive (in terms of required energy, computation, and storage
space).  The second approach 
is more efficient but makes it more difficult to develop general-purpose strategies 
for navigation and loop-closure. We propose a dual
approach. First, global geometric information about environment boundaries is provided 
to the system, either \emph{a priori} or calculated online by
an algorithm such as SLAM. This global geometry is then processed to produce
a strategy providing strong formal guarantees and which can be executed with minimal 
processing power and only simple local sensors.

Inspired by the motion patterns of some commercially available mobile robots, 
we consider simple robots with ``bouncing" behaviors: robots that
travel in straight lines in the plane, until encountering an environment
boundary, at which point they rotate in place and set off again. 
A growing line of work is considering the computational power of individual bouncing strategies
and their applications to robotic tasks and applications in biological, microscale, 
and dynamical contexts. The environment interactions may be mechanical,
with the robot actually making contact with a surface, or may be simulated with
virtual boundariess such as the wire-in-ground systems used by lawn mowing robots
{\color{red} cite?}. Physical implementations of these bouncing behaviors have
been validated experimentally, for example in \cite{LewOKa13} and
\cite{alam2018space}. However, often these lines of work consider only a small
part of the strategy space, such as robot models which only allow $90^{\circ}$
turns. In this work, we present a tractable approach to reasoning over the entire
strategy space of all possible bounce strategies.

This paper presents two ideas for simplifying the characterization and
generation of paths of such mobile robots.  First, that by using the geometric
structure of a polygonal evironment, we can create a combinatorial
representation of the environment that lets us reason over a finite number of
families of paths, instead of the infinite collection of all possible paths.
Second, we can take advantage of the fact that functions which map points
between linear segments are often \emph{contracting}: two points under the
bounce mapping function become closer together.  We use this property to
control uncertainty and synthesize strategies with explicit descriptions of the
amount of allowable uncertainty for successful execution of the strategy.

%%S I am not sure why there is another first, second below.  There are a lot of first-seconds, BTW
%%S Maybe you need a  transition sentence here.  I tried one.
%Our approach to developing robot motion strategies is as follows.
%First, we construct a data structure that represents possible transitions between points on
%the polygon boundary. This data structure can be interpreted as a diagram or graph. 
%Each node in the graph (or region in the diagram) corresponds to a segment of the
%boundary where the visibility polygon at each point is combinatorially equivalent.  This data structure also encodes information about which transitions are 
%uncertainty-reducing.  We then show how this data structure can be augmented and queried to solve different robotic tasks, such as navigation and patrolling.


% two prongs: beauty of geometry and dynamical systems approach
% and practicality of efficient navigation / patrolling / coverage with mobile
% robots

% current draw gain of regular roomba vs. SLAM- or GPS- enabled roomba?
% would guess at least 10x improvement
% email iRobot people for actual stats?

\section{Related Work}

The constrained motion model that we use (forward motion until collision,
followed by rotation) is a
form of \emph{compliant motion}, where task constraints are used to guide task
completion, even when the exact system state is not known. Our approach is
related to the idea of funnelling: using
the attraction regions of a dynamical system to guide states into a goal region.
Funnelling and similar ideas have been developed in the context of manipulation and fine motion control by Whitney
\cite{Whi77}, Mason \cite{Mas85}, Erdmann
\cite{Erd86}, Goldberg \cite{Gol93}, Lozano-P{\'e}rez, Mason, and Taylor
\cite{LozMasTay84}, Lynch and Mason \cite{LynMas95}, and Burridge, Rizzi, and Koditschek \cite{BurRizKod99}.


A key aspect of our robot model is the intentional use of collisions with
environment boundaries, enabled by the advent of more robust, lightweight mobile
robots. Collisions as information sources for such mobile robots have also been
recently explored for multi-robot systems \cite{mayya2017collisions}. Our
specific motion model has been used in works such as \cite{OkaLav06} to
determine minimal information processing requirements for mobile robot tasks.
The first-class study of the motion model's dynamical properties was proposed in
\cite{bounce} and continued in \cite{NilBecLav17}. Our work extends and improves
these analysis tools, and presents new insights from the use of visibility to
discretize the strategy space.

The most closely related work to ours is \cite{LewOKa13}, which addressed the
navigation task with a very similar robot model in polygons. Their robot moves
in a straight line until encountering an environment boundary, at which point it
is able to rotate in place, with some bounded nonzero nondeterministic error
cone.
They then generate a strategy as a sequence of bounce angles that navigate
the robot between given start and end locations in a known environment. They
introduce the idea of ``safe actions,'' which place the entire forward projected
state of the robot within a single linear segment of the polygonal environment.
However, this algorithm is not complete, due to the problem formulation taking
the robot's motion uncertainty as a fixed input. Our approach is to consider all
possible error cones, and return bounds on the required accuracy of movement as
an output of the algorithm.

%due to the method used to discretize
%the environment boundary and the restriction of only allowing deterministic
%transitions between boundary segments. Their navigation graph has $O(n^4)$
%nodes, while ours includes only $O(n^2)$ nodes.

%%S Be careful with this `` and '' and that other one.  Make sure it turns out OK each time in the pdf outpout.  I prefer `` and '' to the single-character quotes.  I can't recall why any more.


In \cite{alam2017minimalist} and \cite{alam2018space}, the authors describe
navigation, coverage, and localization algorithms for a robot model, focused
on bounce laws which turn a fixed amount relative to the robot's prior heading. 
Their approach uses a grid discretization of the robot configuration space and actuation
space, and then searches the discretized dynamical system for limit cycles. The
algorithm is complete and correct up to discretization error, though periodic
trajectories may exist which require bounce angles not allowed by the
discretization. By using a discretization induced by the environment geometry,
our approach considers all possible bounce strategies.



The questions we pose, and our methods of attacking the problem, are related to
work on visibility in computational geometry. Visibility graphs have been
extensively in robotics, but usually in the context of the vertex visibility
graph with the goal of avoiding obstacles {\color{red} add cites}.  If we instead use collisions strategically, then we require a slightly more
powerful data structure: the edge visibility graph for a partition of a polygon
$P$. The edge visibility graph was analyzed along with the vertex-edge
visibility graph in \cite{rourke_viz}. {\color{red} they have an O(n+k) algo for
constructing vertex-edge. But correspondence to edge requires $O(n^2)$ at least
- confirm? Also, is this valid w/out general position? Strong assumption on g.p.
in O'Rourke paper}.

%%S Citations for visibility motion planning: Nil69, SimLauNis00
%%S Hmm..this could have said all of combinatorial motion planning is devoted to obstacle avoidance, whereas here we use it to study how to hit obstacles!

%%S I think you do not use - properly.  Try to avoid.  Most of the time is should be ; or sometimes : .   
The dynamical system defined by our robot model is related to \emph{dynamical billiards}. Many 
possible reflection laws have been studied;
the most common is purely specular reflection, but slightly modified laws have
also attracted recent interest \cite{DelMagno2014,billiards,pinball}. 
One very similar work was inspired by the dynamics of microorganisms; in \cite{microorganism2017}, 
the authors show that 
\textit{Chlamydomonas reinhardtii} ``bounce'' off boundaries at a specific
angle depending on their body morphology. They characterize periodic and
chaotic trajectories of such agents in regular polygons, planar curves, and other environments, 
without a focus on generating control strategies.

Our work is also related to problems in computational geometry that consider what
parts of a polygon will be illuminated by a light source after multiple
reflections (as if the edges of the polygon are mirrors). It has been shown that
the complexity of the region lit in an $n-$gon after $k$ bounces is $O(n^{2k})$
\cite{Aronov1996}. Another interesting line of work considers \emph{diffuse}
reflections \cite{prasad1998visibility}, which are related to our nondeterministic bounces.

We are working toward a generalization and hierarchy of robot models, in a
similar spirit to \cite{brunner2008simple}. Their basic robot model, the simple
combinatorial robot, is able to scan all visible vertices and detect the
presence of an edge between them. It is able to choose a destination vertex and
move in a straight line to that vertex. They then augment this basic robot model
with sensors such as pebbles, angle-measuring devices, and a reflexity detector.
They then construct a hierarchy of these robot models, showing for instance that
some can construct the vertex visibility graph of a polygonal environment
and others cannot. Our questions are related but different: if the robot is
given a compact, purely combinatorial environment representation, then what tasks is 
it capable of accomplishing with only local sensing?
%%S Perhaps you need to define what you mean by local sensing, the first time you use it.

\section{Model and Definitions}

%%S Using singular rather than plural often makes life better in definitions.
We consider the movement of a point robots in simple 
polygonal environments\footnote{All index arithmetic for polygons with $n$ vertices is mod $n$ 
throughout this paper. We do not require polygons in general position.}. We define our robot to move forward in a straight line, until
encountering an environment boundary (such as when a bump or range sensor is
triggered). Once at a boundary, the robot is able to rotate in place.
Of course, robots rarely move perfectly, so our analysis will assume the
robot has some uncertainty in its motion execution, modelled
nondeterministically.
%%S Above:  By simple, you mean either simply connected, or you must remove the word simple.

More formally, the model is:
\begin{itemize}
\item The \emph{configuration space} $X = P \times S^1$. $P$ is a simple polygon with 
piecewise linear boundary $\partial P$, and $S^1$ is the robot's orientation in the plane. For the most part, one can ignore configurations in the interior
of the polygon and only consider transitions between points and intervals on the
boundary. Let $s \in \partial P$ refer to a point on
the boundary of without an associated robot orientation.
%\item The \emph{observation space} $Y$ of sensor readings from sensors that the
%robot is equipped with, and the \emph{sensor mapping} $h: X \to Y$ which maps
%the robot state to sensor readings. We consider robots equipped with a contact 
%sensor, defined as $h(x) = 1$ if $x \in \partial P \times S^1$, and $h(x) = 0$ 
%otherwise.
\item The \emph{action space} $U = [0,\pi]$, in which $u \in U$ is executed when
the robot is in contact with an environment boundary; $u$ is measured counterclockwise
relative to the boundary. The action of departing the boundary while oriented at the boundary
normal corresponds to $u = \pi/2$.
\item The \emph{state transition function} $f: X \times U \to X$, which
describes how the state of the robot changes according to which action is
chosen. We will often lift this function to act nondeterministically over sets
of states and actions, propagating each state forward with each possible action,
and unioning the resulting set of states. 
\item We model time as proceeding in stages; at each stage $k$, the robot
is in contact with the environment boundary, executes an action $u_k$, and then
moves forward until the next contact with the boundary at stage $u_{k+1}$.
\end{itemize}

\begin{figure}
    \includegraphics[width=0.8\linewidth]{figures/bounce_examples.pdf}
    \centering
    \caption[test]{\label{fig:bex}Examples of different ``bounce laws'' which can be implemented on
mobile robots. In the first row, $b(\alpha, \theta) = \theta$, which we refer to
as a \textbf{fixed} bounce law. In the second row, we have a \textbf{monotonic
fixed} bounce law, where
$b(\alpha, \theta) = \theta$ or $\pi-\theta$, depending on what is necessary to
preserve monotonicity of travel direction along the $x$-axis. In the third
row, $b(\alpha, \theta) = \alpha - \theta$, rotating $\alpha$ through $\theta$ in the clockwise
direction. It is possible that this rotation will cause the 
heading of the robot to still be facing into the boundary, in which case the robot 
performs the rotation again until its heading points into the free space. We
refer to this as a \textbf{relative} bounce law ($\alpha$ appears on the
right hand side of the bounce law).
}
\end{figure}

\begin{definition}
Let $\alpha: (0,\pi)$ be the robot's incoming heading relative to the
environment boundary. A \textbf{bounce law} $b$ maps $\alpha$ to an action
$u$, and determines how the robot will reorient itself when it collides with a
boundary. Bounce laws are defined in the
frame where the environment normal is aligned with the positive $y$ axis and the
robot's point of contact with the boundary is the origin.

A \textbf{nondeterministic bounce law} is one which returns a set of actions
instead of a singleton. In this paper, we will restrict such bounce laws to
return a convex set of actions (a single interval in $(0, \pi)$).
\end{definition}

For example, a specular bounce (laser beams, billiard balls) has bounce law
$b(\alpha) = \pi - \alpha$. See Figure \ref{fig:bex} for more
examples of bounce laws. 

\begin{definition}
A \textbf{bounce strategy} is a sequence of bounce
laws.
\end{definition}

Uncertainty is modelled by computing strategies over nondeterministic bounce
laws, which result in the robot achieving its goal as long as it executes an
action in the specified \emph{interval} at each stage.

Given a polygonal environment (such as the floor plan of a warehouse or office
space), we would like to synthesize bounce strategies which allow a robot to
perform a given task (in our case, navigation or patrolling).



\section{Visibility-Based Boundary Partitioning} \label{sec:partition}

First, we must find a way to discretize the continuous space of all possible
transitions between points on $\partial P$. We find a visibility-based partition
which encodes the idea of some points on $\partial P$ having different
available transitions.

\begin{definition}
The \textbf{visibility polygon} of a point $s$ in a polygon $P$ is the polygon
formed by all the points in $P$ which can be connected to $s$ with a line
segment which lies entirely within $P$.
\end{definition}

Imagine a robot sliding along the boundary of a polygon, calculating 
the visibility polygon as it moves. In a convex polygon, nothing exciting 
happens, but in a nonconvex polygon, the reflex vertices (vertices with an
internal angle greater than $\pi$) cause interesting
behavior.

As the robot slides, its visibility polygon may change continuously: edges
shrink or grow, but the combinatorial structure of the polygon remains the same.
However, when the robot aligns with a reflex vertex $r$ and another vertex $v$ (visible
from $r$), a combinatorial change will occur in the visibility polygon. Either 
$v$ will become visible to the robot, adding an edge to the visibility 
polygon, or $v$ will disappear behind $r$, removing an edge from the visibility polygon.

To compute all such points where the visibility polygon changes structure, we
must compute the \textbf{partial local sequence}, defined in \cite{rourke_viz}.
The partial local sequence is a sequence of points on $\partial P$, associated with 
a vertex $v_0$ in $P$, constructed by shooting a ray through $v_0$ from every vertex in $P$
that is visible from $v_0$ and keeping the resulting sequence of intersections with
$\partial P$. If $v_0$ is reflex, some of the rays shot through it may intersect
$\partial P$ in the interior of existing edges. See Figure \ref{fig:pls} for an
example of the vertices in the partial local sequence of $v_0$ (blue dots with
accompanying rays). Each point in the partial local sequence marks the point
where a visible vertex appears or disappears behind a reflex vertex.

Thus, once all the partial local sequences have been inserted into the original
polygon, the resulting points along the boundary define segments where two points in the same interval can see the same edge set of the
original polygon (though they may see different portions of those edges). Thus,
we can reason over a finite set of transitions between these intervals, instead
of the infinite set of possible transitions between points on the boundary of
the original polygon. See Algorithm \ref{algo:insert} for a pseudocode
description of this partitioning process.

Let $P'$ be the polygon $P$ with all partial local sequence points inserted.

\begin{definition}
The \textbf{edge visibility graph} of a polygon $P$ has a node for each edge of
$P$, and has an arc between two nodes $(e_i, e_j)$ if and only if there is a
point $s_i$ in the open edge $e_i$ and a point $s_j$ on the open edge $e_j$ such
that $s_i$ and $s_j$ can be connected with a line segment which is entirely
within the interior of $P$.
\end{definition}

%\begin{definition}
%Let $\thicksim$ be an equivalence relation such that for $s_1, s_2 \in \partial
%P$, $s_1 \thicksim s_2$ if and only if the visibility polygons of $s_1$ and $s_2$ have
%the same .
%\end{definition}
%
%This relation satisfies the necessary
%properties {\color{red} todo but easy},
%
%\begin{itemize}
%\item reflexivity
%\item symmetry
%\item transitivity
%\end{itemize}
%
%The partition of $\partial P$ created by Algorithm \ref{algo:insert} are the
%equivalence classes induced by $\thicksim$ {\color{red} todo but easy}.

\begin{figure}[h]
\centering
\begin{subfigure}{0.4\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/partial_local_sequence.png}
    \caption{Partial local sequence for $v_0$}\label{fig:pls}
\end{subfigure}%
\begin{subfigure}{0.4\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/chestnut_5.png}
    \caption{An example polygon for which the bounce visibility graph has
$O(n^4)$ edges. \label{fig:t4}}
\end{subfigure}
\end{figure}


\begin{definition}
Let the \textbf{bounce visibility graph} be the directed edge visibility graph of
$P'$.
\end{definition}

%%S Be careful.  While is not although or whereas.  Not referring to time here.
Although visibility is a symmetric property, we use directed edges in the
bounce visibility graph so that 
we can augment each edge with a label function which stores
geometric constraints on the visibility from one edge to another, which are
not symmetric and govern what actions the robot can take to accomplish that
transition. See Section \ref{sec:safe} for further exploration of this idea.
%%S I hope you are checking for missing section references!

We now define the \textbf{bounce visibility diagram}, which is a
representation of the edge-edge visibility of a polygon $P'$. This representation
was inspired by link diagrams \cite{efrat2000sweeping,tan_sweep}, though our
diagrams represent only a link distance of one.
%We choose an arbitrary vertex
%$v_0$ of $P$ as the origin, and parameterize points $p \in \partial P$ by the
%counterclockwise distance from $v_0$, divided by the perimeter length of
%$\partial P$. This parameterization defines a bijective function $s: [0,1) \to \partial P$.
If $|\partial P'|$ is the perimeter length of $\partial P'$, let the $x-$axis of the
bounce visibility diagram be the interval $[0, |\partial P'|)$, where the
endpoints of the interval are identified. Let the $y-$axis of the diagram be a
parameter $\theta$ which is an angle between $0$ and $\pi$.
We also use a labelling function $\ell: \partial P' \to [0, \ldots, n']$ to
label each point $s \in \partial P'$ with the unique index of the edge segment in $P'$ that it
belongs to. Thus, for a point $s \in \partial P'$, and an angle $\theta$, we can
compose $\ell$ and the state transition function $f$ to compute
$l(f(s,\theta))$. The graph of $l \circ f$ is the bounce visibility diagram. The
diagram indicates which edges
of $\partial P'$ are visible, and what actions the robot could take to
transition from one edge to another.

{\color{red} current diagram just shows lines where the visibility polygon at s
changes combinatorial structure. In between the lines, we are not guaranteed
that all transitions land on the same segment. Would need to do another
iteration of partition algorithm to determine destination segments.}

{\color{red} We can change the diagram so regions are assigned a unique "color" or "label" based on
destination segment, and get plots to reflect this. Assuming we do, the
following analysis holds}

The bounce visibility diagram gives us some visual insight into the structure of
the problem. For example, in Figure \ref{fig:regular_pent_bvd} we can see that
there are intervals of $\theta$ for which we can draw lines horizontally across
the diagram without crossing the solid lines. If we can draw a horizontal line
for $\theta$ from $v_i$ to $v_{i+1}$, all transitions $f(s,\theta)$
for any $s \in v_i v_{i+1}$ will be mapped to points in a single segment in
$P'$. If we can
draw such lines across the entire diagram, this indicates that this property
holds true for the entire polygon. We call such transitions \emph{safe
actions}, since for a range of $\theta$, $f(s,\theta)$ maps from one equivalence
class on the boundary to another without splitting the $s$-interval.

\begin{figure}
\centering
\begin{subfigure}{0.35\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/regular_pent.png}
\end{subfigure}%
\begin{subfigure}{0.35\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/regular_pent_bvd.png}
\end{subfigure}
\caption{The bounce visibility diagram for the regular pentagon. }
\label{fig:regular_pent_bvd}
\end{figure}

{\color{red} need nice example here, something a little more exciting than
regular pentagon, maybe two convex shapes with hallway between}


\begin{algorithm}
\caption{Partition the boundary of a polygon into visibility
equivalence classes.}
\label{algo:insert}
\begin{algorithmic}
\Procedure{PartitionPoly}{$poly$}
\State $v_{new} \gets \{\}$
\State $reflex\_verts \gets$ \Call{GetReflexVerts}{$poly$}
\For{$v_r$ in $reflex\_verts$}
    \For{$v_{vis}$ in \Call{VisibleVerts}{$poly, v_r$}} 
        \State $v_{new} \gets$ $v_{new} \cup$ \Call{ShootRay}{$v_{vis}, v_r$}
    \EndFor
\EndFor
\State $partitioned\_poly \gets$ \Call{InsertVerts}{$v_{new}, poly$}
\State \textbf{return} $partitioned\_poly$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{proposition} The bounce visibility graph for a polygon with $n$ vertices has 
$O(n^2)$ vertices and $O(n^4)$ edges.
\end{proposition}

\begin{proof}

Consider a polygon $P$ with $n$ vertices, $r$ of which are reflex vertices. To
construct the bounce visibility graph, we insert the vertices of the partial
local sequence for each vertex in $P$. For a convex vertex, its partial local sequence 
will not add any new vertices to $P$. However, a reflex vertex can add $O(n)$ new vertices. 

Up to half of the vertices in the polygon can be reflex, so the complexity of
$r$ is $O(n)$. Therefore, the number of vertices in $P'$, returned by Algorithm
\ref{algo:insert} is $O(n^2)$. Each vertex indexes an edge in $P'$, and
thus a node in the edge visibility graph of $P'$. At most, a given vertex in $P'$ may see all other vertices, so in the worst
case, the bounce visibility graph will have $O(n^4)$ edges. See Figure
\ref{fig:t4} for an example of such a polygon, and the Appendix for a proof of
its complexity.
\qed

\end{proof}



%\begin{figure}
%
%\centering
%\begin{subfigure}{0.35\textwidth}
%\centering
%\includegraphics[width=\linewidth]{figures/color_pent.png}
%\captionof{figure}{\label{fig:color_pent}}
%\end{subfigure}%
%\begin{subfigure}{0.35\textwidth}
%\centering
%\includegraphics[width=\linewidth]{figures/bvd.png}
%\end{subfigure}
%\caption{A polygon and its corresponding bounce visibility diagram.}
%\label{fig:bvd}
%\end{figure}
%

\section{Safe Paths} \label{sec:safe}

{\color{red}
Show with examples how useful trajectories in example correspond to queries to
the graph or diagram.}

One major advantage of this approach is that it allows us to characterize
properties of families of paths the robot may take. For example, the  
two paths in Figure \ref{fig:twopaths} are produced by different sequences of
bounce laws and visit different points of $\partial P$, but have the same sequence of edge collisions and have the same overall
dynamical behavior (escape the room on the left, travel through hallway, then
patrol the room on the right in a periodic orbit).

\begin{figure}
\centering
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=\linewidth]{figures/twoc_a}
\end{subfigure}%
\begin{subfigure}{0.5\textwidth}
\includegraphics[width=\linewidth]{figures/twoc_b}
\end{subfigure}
\caption{Two paths demonstrating similar high-level properties with different
collision points and bounce strategies.}
\label{fig:twopaths}
\end{figure}

To characterize some of these families of paths, we will use the boundary
partition technique defined in Section \ref{sec:partition}, then define
\emph{safe actions} between segments in the partition, where safe actions are
ones which are guaranteed to be successful from anywhere in a segment under an
interval of bounce angles.

\begin{definition}
Two edges $e_i,e_j \in \partial P$ are \textbf{entirely visible} to each other if
and only if every pair of points $s_i \in e_i$ and $s_j \in e_j$ are visible (the
shortest path between $s_i$ and $s_j$ lies entirely within $P$).
\end{definition}

\begin{proposition} \label{prop:saferange}
Given two entirely visible line segments $e_i$ and $e_j$, it is possible to compute
the maximum range of angles $\bm{\tilde{\theta}_{max} = [\theta_r, \theta_l]}$ such
that $f(s, \theta) \in e_j$, for all $s \in e_i$ and for all
$\theta \in \tilde{\theta}_{max}$, or we may compute that no such range exists.
\end{proposition}

\begin{proof}

Let edge $e_i = (v_i, v_{i+1})$ be aligned with the positive $x$ axis with the clockwise
endpoint at the origin, without loss of generality. Due to the edges being
entirely visible, $e_j = (v_j, v_{j+1})$ must be in the top half of the plane, above
$e_i$.

Take the quadrilateral formed by the convex hull of the edge endpoints.
Let the edges between $e_i$ and $e_j$ be $e_l = (v_i, v_{j+1})$ and the right-hand edge 
$e_r = (v_{i+1}, v_j)$. Let $\theta_{l}$ be
the angle between $e_l$ and the positive $x$ axis ($0 < \theta_l < \pi$); similarly
for $e_r$ and $\theta_r$. See Figure \ref{fig:bounce_range} for an illustration of
the setup. 

Note that if $e_l$ and $e_r$ are extended to infinity,
they cross either above or below edge $e_i$, or they are parallel.

\emph{Case 1:} $e_l$ and $e_r$ would meet below edge $e_i$. Then,
$\theta_l > \theta_r$ and if a ray is cast from any point on $e_i$ at angle
$\theta \in [\theta_r, \theta_l]$, the ray is guaranteed to intersect $e_j$ in its
interior.

\emph{Case 2:} $e_l$ and $e_r$ would meet above edge $e_i$. Then, $\theta_l <
\theta_r$, and there is no angle
$\theta$ such that a ray shot from \emph{any} point on $e_i$ will intersect
$e_j$.
To see this, imagine sliding a ray at angle $\theta_l$ across the quadrilateral
- at some point before reaching $v_{i+1}$, the ray must stop intersecting $e_j$,
else we would have $\theta_l > \theta_r$.

\emph{Case 3:} $e_l$ and $e_r$ are parallel. This implies that $\theta_{l} =
\theta_{r}$, which is the only angle for which a transition from any
point on $e_i$ is guaranteed to intersect $e_j$, and $\tilde{\theta}_{max}$ is a
singleton set.

Thus, for each case, we can either compute the maximum angle range or determine
that no such angle range exists.
\qed

\end{proof}

Cases 1 and 3 correspond to our definition of a \emph{safe actions}.

\begin{definition} \label{def:sa}
A \textbf{safe action} between segments $e_i$ and $e_j$ is an action $u$ such
that $u \in \tilde{\theta}_{max}$ and $\tilde{\theta}_{max}$ is nonempty for 
transition $e_i$ to $e_j$.
\end{definition}

A safe action from $e_i$ to $e_j$ is guaranteed to
have $f(s,u) \in e_j$ for any $s \in e_i$ and $u \in \tilde{\theta}_{max}$.
Note that this definition is very similar to the definition of an interval of
safe actions from \cite{LewOKa13}; the main differences in approach are the
generation of boundary segments, methods of searching the resulting graph, and
how we generate constraints on robot uncertainty instead of assuming uncertainty
bounds are an input to the algorithm.

\begin{lemma}
If two segments are entirely visible to each other, there will be at least one safe
action between them.
\end{lemma}

\begin{proof}
From the proof of Proposition \ref{prop:saferange}, we can see that if case one
holds in one direction, case two will hold in the other direction, so a safe
action must exist from one edge to the other in one direction. If case three
holds, there is a safe action both directions but $\tilde{\theta}_{max}$ is a
singleton set.
\end{proof}

\begin{corollary} \label{coro:neighbor}
If two segments share a vertex which is not reflex, there exist safe actions
from one to the other in both directions.
\end{corollary}


%\begin{definition}
%We say that two robot trajectories are in the same \textbf{combinatorial family}
%if they have the same number of collisions, and the collisions at stage $k$
%occur in the same segment of $P'$, for all $k$. Additionally, each transition in
%the trajectory must be performed by a safe action.
%\end{definition}


%\begin{definition}\label{def:transition}
%For edge $e_{ij} \in E(G)$, for each point $x$ in the edge $i$, there 
%exists a range of angles $\tilde{\theta}$ such that $f(x,\theta) \in j$ for
%some $\theta \in \tilde{\theta}$.
%\end{definition}
%
%\begin{proof}
%By construction, edge $e_{ij}$ exists if and only if there is a point $x$ on the (open)
%segment $i$ and a point $y$ on the (open) segment $j$ such that $x$ and $y$ are
%visible to each other. Since $y$ is in the open segment, there will always be some $\epsilon$-neighborhood around
%$y$ which is also visible from $x$, and the endpoints of this
%$\epsilon$-neighborhood define a range of angles at which the robot may leave
%$x$ and arrive on segment $j$.
%
%This angle range can be constructed through simple trigonometry for a
%given point and target segment.
%\end{proof}

%\begin{definition} \label{def:angrange}
%Given two mutually visible segments $i,j \in \partial P$, there exists a range 
%of angles from which a transition from $i$ to $j$ is possible from from some
%point in $i$ to some point in $j$.
%See Figure \ref{fig:bounce_range}. This interval, $[\theta_{min}, \theta_{max}]$, 
%is the union of the point-wise angle intervals described in Definition
%\ref{def:transition}.
%\end{definition}

\begin{figure}
%    \centering
%    \begin{subfigure}{0.5\textwidth}
%    \includegraphics[width=0.4\linewidth]{figures/bouncerange.png}
%    \caption{Angle range such that a transition exists for some point on
%orginating edge.}
%\label{fig:bounce_range}
%    \end{subfigure}%
%    \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.7\linewidth]{figures/bouncerange_min.pdf}
    \caption{Angle range such that a transition exists for all points on
originating edge (left: such a range exists, right: such a range does not
exist)}
\label{fig:bounce_range}
%    \end{subfigure}
\end{figure}

\section{Dynamical Properties of Paths}

%Many tasks required of mobile robots can be specified in terms of properties of
%the path the robot takes through space. \emph{Navigation} requires a path that
%begins and ends in specified regions; \emph{patrolling} requires a repeatable
%path that satisfies some coverage criterion; \emph{localization} requires a path
%which reduces uncertainty in the robot's position.

Our motion strategy allows us to disregard the robot's motion in the interior of
$P$. Instead, the robot's state is an interval 
along the boundary $\partial P$, and we can formulate transitions as a discrete
dynamical system under the transition function $f$. The properties of this
dynamical system can be used to engineer paths corresponding to different robot
task requirements.

One such generally useful property of mapping functions is being a \emph{contraction mapping}: 
two points, when mapped through the
transition, always become closer together. We can use this property to control
uncertainty in the robot's position, and to engineer stable limit cycles in
Section \ref{sec:cycles}.

\begin{definition}
Let $\phi_{ij}$ be the interior angle between two edges $e_i, e_j \in \partial P$ if
they are extended to infinity. 
\end{definition}

The case where the segments are parallel will be
handled separately where necessary. 

\begin{definition}

A function $g: \mathbb{R} \to \mathbb{R}$ is a contraction mapping if

\begin{equation*}
|g(x) - g(y)| \leq c |x-y|
\end{equation*}

where $0 \leq c < 1$.
\end{definition}

\begin{definition}
Suppose segment $e_i$ is aligned with $x$ axis with its normal pointing up and
segment $e_j$ is above segment $e_i$. If the intersection of segment $e_i$ and
$e_j$ is
on the left of segment $e_i$, then call the transition from $e_i$ to $e_j$ a left
transition; if the intersection is on the right of segment $e_i$, then call the
transition a right transition.
\end{definition}

\begin{lemma} \label{lemma:angrange}
If the transition from segment $e_i$ to segment $e_j$ is a left transition, then the
transition function $f(x, \theta)$ between segments $e_i$ and $e_j$ is a contraction
mapping if and only if $\theta > \frac{\pi}{2}+\frac{\phi_{i, j}}{2}$;
otherwise, the transition function $f(x, \theta)$ is a contraction mapping if
and only if $\theta < \frac{\pi}{2}-\frac{\phi_{i, j}}{2}$.
\end{lemma}

The proof is a straightforward application of the law of sines, and is included
in the appendix.

\begin{corollary} \label{coro:existcontract}
There exists a range of angles for which $f$ is a contraction mapping for transitions between two adjacent 
segments with an internal angle less than $\pi$ (pairs of adjacent non-reflex
segments along $\partial P'$).
\end{corollary}

\begin{definition}
The \textbf{contraction coefficient} of a transition between two
line segments is the ratio of the absolute distance between points before and after.
For a transition from $e_i$ to $e_j$ in $\partial P$, let the contraction
coefficient be denoted as $C(\theta, \phi_{i, j})$. 
For a left transition, $C(\theta, \phi_{i, j}) = | \frac{\sin(\theta)}{\sin(\theta - \phi_{i, j})} |$; 
for a right transition,  $C(\theta, \phi_{i, j}) = | \frac{\sin(\theta)}{\sin(\theta + \phi_{i, j})} |$.
\end{definition}

For a sequence of transitions $f_0, \ldots, f_k$, we can construct the overall
mapping from the domain of $f_0$ to the range of $f_k$ through function
composition. Since $f$ is a linear mapping, the contraction property of a composition 
of multiple bounces can be determined by multiplying the contraction
coefficients.

\begin{definition}
Given a sequence of $m$ transitions $F = \{f_0, f_1, \ldots, f_{m-1}\}$, at stage $k$ the robot 
will be located on edge $e(k)$ and will depart the edge with
action $\theta_k$. Then, the contraction coefficient of the overall robot
trajectory $f_{m_1} \circ \ldots \circ f_0$ is

$$ C(F) = \prod_{k=0}^{m-1} C(\theta_{e(k)}, \phi_{e(k), e(k+1)}) $$.
\end{definition}

If $C(F) < 1$, the strategy $b_1, \ldots, b_k$ along that sequence of edges
results in a contraction mapping. This is true even if some transition along
the way is not a
contraction mapping, since $C(F)$ is simply the ratio of distances
between points before and after the mapping is applied. Furthermore, the value
of $C(F)$ tells us the exact ratio by which the
size of the set of possible robot states has grown or shrank after $F$ is
executed.

%and the constraints on the angle range $\tilde{\theta}$ can be propagated through the 
%composition by intersecting the angle intervals.

\subsection{Cycles} \label{sec:cycles}

A very common use of contraction mappings is to prove the existence of fixed
points, due to the power of the Banach fixed point theorem \cite{Granas2003}
{\color{red} state exactly the theorem}.
The exact condition needed is for a contraction mapping to map an interval back
to itself. Since the transition function of a path is the
composition of the individual transition functions, we can create a self-mapping 
by constructing a path which returns to its originating edge. A fixed
point of this mapping is a stable limit cycle, which can be used to reduce an
interval of possible robot positions to an arbitrarily small set under enough
iterations.

Such paths in regular polygons were characterized in \cite{NilBecLav17}.
Here, we present a more general proof for the existence of limit cycles in all
convex polygons.

%\begin{definition}
%A \textbf{convex $n$-cycle} is If a limit cycle inside a convex polygons with $n$ edges forms another convex
%polygon with $n$ edges, we call this limit cycle as convex $n$-cycle.
%\end{definition}

\begin{definition}
$\phi_{P,min}$ is the smallest interior angle in a polygon $P$.
\end{definition}

\begin{theorem} \label{thm:convex}
For all convex polygons with $n$ edges, there exist fixed-angle bouncing
strategies which result in a period $n$ limit cycle regardless of the robot's start position.
\end{theorem}
\begin{proof}

Without loss of generality, assume $\theta \in (0, \frac{\pi}{2}]$. Consider the
triangle formed by two adjacent edges $e_i$, $e_{i+1}$ of $P$. The robot will
bounce from $e_i$ to $e_{i+1}$ regardless of its start position if and only if
$\theta \in (0, \angle v_{i+2}v_{i}v_{i+1})$. Thus, the robot will always bounce
to the next adjacent edge if and only if
$\theta \in (0, \min_{i}(\angle v_{i+2}v_{i}v_{i+1})$.

Suppose we have two start positions $x$ and $y$ on edge $e_0$ and the two
corresponding trajectories under a constant fixed bounce law $b(\alpha) = \theta$. Denote the robot's
position on $e_k$ after bouncing $k$ consecutive edges as $f^{k}(x)$ and
$f^{k}(y)$ respectively. $\triangle f^{k}(x)v_{k+1}f^{k+1}(x)$ and
$\triangle f^{k}(y)v_{k+1}f^{k+1}(y)$ are similar triangles since they share a
common internal angle of the polygon, $\phi_{k,k+1}$, and the bouncing angle
$\theta$.

The distance between the two trajectories on $e_0$ after the robot bounces off
every edge of the polygon, i.e., bounces off $n$ times, is
$d(f^{n}(x), f^{n}(y))$.

Since function composition multiplies the coefficients $C(\theta, \phi)$, 
the distance between $x$ and $y$ changes after one orbit of the polygon by the
ratio

\begin{eqnarray*}
\frac{d(f^{n}(x)), f^{n}(y))}{d(f^{0}(x), f^{0}(y))} = \prod_{i = 0}^{n-1}
C(\theta, \phi_{i-1, i}).
\end{eqnarray*}

If $\prod_{i = 0}^{n-1} C(\theta, \phi_{i}) < 1$, then $f^k(x)$ is a contraction
mapping from $e_0$ back to iteself, and by the Banach fixed-point theorem, it
has a unique fixed point \cite{Granas2003}.

Since all transition in this example are right transitions, the constraint $C(\theta,\phi_{i-1, i})<1$ is equivalent to $\theta < \frac{\pi}{2}-\frac{\phi_{i-1, i}}{2}$. So we can guarantee that this condition holds for the orbit by requiring

\begin{equation*}
\theta \in (0, \min(\min_{i = 0, 1, \dots, n-1}(\angle v_{i+2}v_{i}v_{i+1}),
\frac{\pi}{2}-\frac{\phi_{i-1, i}}{2})),
\end{equation*}

in which case the fixed-angle bouncing strategy with $b(\alpha) = \theta$ leads to a convex
cycle which visits each edge of $P$ sequentially, regardless of the robot's start position.
\qed

\end{proof}


\section{Applications}

We have presented data structures (the bounce visibility diagram and bounce
visibility graph, augmented with contraction information) which can be applied
to several different strategy synthesis problems in mobile robotics.

\subsection{Navigation}

Here, we define the \emph{navigation} task. Informally, we wish to decide if
there is a strategy which uses only nondeterministic bounce laws which can cause
the robot to move from any point in a given set of starting points in $\partial P$ to
another given goal set. We require that the start and goal sets are
convex (a single interval $[s_1, s_2] \in \partial P$).

\begin{definition}
\textbf{Navigation}:
Given a polygonal environment $P$, a starting convex set $S \in \partial P$ of possible robot positions along the
environment boundary, and a goal convex set $G \in \partial P$, determine a strategy $\pi$ which
will be guaranteed to take the robot from any point in $S$ to a point in $G$, or
determine that no such strategy exists.
\end{definition}

Using Definition \ref{def:sa}, we can create a \emph{safe roadmap} out of the 
bounce visibility graph by traversing all edges and removing edges with an 
empty $\tilde{\theta}_{max}$, and labelling the remaining edges with the interval 
of safe actions. The edges in the safe roadmap are a subset of all the possible
preimages of nondeterministic transitions.

The resulting graph, $G_{safe}$, can be used to generate strategies for the
robot which take it from segment $e_{start}$ to segment $e_{end}$: each path in
$G_{safe}$ from the node corresponding to $e_{start}$ to $i_{end}$ represents
such a strategy. In general, one can find all paths (up to a bounded length)
between a start and goal set and then use different techniques to transform this
path set into a strategy. See Algorithm \ref{algo:nav} for a pseudocode
description of this process. The definition of \textsc{getStrategy} can vary;
here we detail a few options.


\begin{algorithm}
\caption{Generating a nondeterministic bounce strategy for navigation from any
point in start set $S$ to a point in goal set $G$.}
\label{algo:nav}

\begin{algorithmic}
\Procedure{Navigate}{$poly$, $G$, $S$, $criterion$}
\State $BVD \gets$ \Call{PartitionPoly}{$poly$}
\State $G_{safe} \gets$ \Call{mkSafeGraph}{$BVD$}
\State $paths \gets$ \Call{GetAllPaths}{$BVD$, $G$, $S$,$k$}
\Comment $k$ is an upper bound on the path length
\State $strategy \gets$ \Call{getStrategy}{$paths$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Making Concise Strategies}

The edge
information along the path can be used to create more concise strategies: to
determine if a path can be executed using a constant controller $b(\alpha,
\theta) = \theta$, intersect all the intervals along the path and check if the
resulting interval is nonempty. If it is, the path may be executed with any
$\theta$ in that interval. Indeed, this execution operation gives us the exact
accuracy range needed to successfully execute a trajectory in the family defined
by the path in $G_{safe}$.


In general, deciding whether a given path may be
executed with $k$ constant fixed bounce law controllers is the interval
hitting-set problem, which is NP-hard, though in practice we are mostly
interested in small $k$ {\color{red} more convincing argument about why this is not so
bad, add cite}.

\subsubsection{Incorporating Contraction Mappings}

Say we are given a path in the bounce visibility graph which contains an unsafe
transition (perhaps the robot must visit a sequence of boundary segments in a
specific order, or perhaps there is no safe path between two segments). We may
use limit cycles to reduce the uncertainty in the robot's position enough to
transform the unsafe transition into a safe transition.

{\color{red} add Israel's result on number of iterations necessary to make distance from
limit cycle less than $\delta$}

\subsubsection{Completeness}

To understand how much of the environment the robot may reach with only safe
transitions, first we observe that for every segment, safe transitions always exist
for two angles ranges. These ranges are the ones bordering the segment itself:
by staying close enough to the boundary, the robot may guarantee a safe
transition (as well as a contraction mapping).

\begin{lemma}
Each segment $e$ in the partitioned polygon $\partial P'$ has at least two safe transitions
leaving $e$.
\end{lemma}

\begin{proof}

{\color{red} clean up explanation}

By Corollary \ref{coro:existcontract}, if a segment $e_i$ has an adjacent segment
where the internal angle between the segments is less than $\pi$, a contracting
transition exists between the segments: all actions where $\theta < \pi/2 -
\phi_{i,i+1}/2$ or $\theta > \pi/2 + \phi_{i-1,i}/2$, depending on the direction
of the transition.

The other case to consider is if one of the adjacent edges to $e_i$ is
separated by a reflex angle. If so, by Algorithm \ref{algo:insert} a vertex
will be inserted in line with $e_i$ on the closest visible edge. Call the
segment counterclockwise from this inserted vertex $e_j$. 
By Lemma
\ref{lemma:angrange}, there must be a contraction mapping from $e_i$ to $e_j$.
The transition must also be safe, by the same argument as Corollary
\ref{coro:neighbor}. The same argument holds for left transitions.
\qed
\end{proof}

\begin{conjecture}
Every segment in $\partial P'$ is part of a safe, contracting cycle.
\end{conjecture}

\begin{conjecture}
All segments in the partitioned polygon $P'$ are reachable by a safe action from
at least one other segment.
\end{conjecture}

\begin{conjecture}
Any segment in $P'$ is reachable from any other segment along a path of safe
actions.
\end{conjecture}

Don't have a proof but have lots of experiments with no counterexamples.


%\begin{lemma}
%Given points $x,y \in \partial P$, let $v_x \in V(BVG)$ be the node representing
%the segment in $\Pi$ that contains $x$, and $v_y$ be the node corresponding to
%the segment containing $y$. Then, a path in $BVG$ from $v_x$ to $v_y$ corresponds
%to a family of strategies which take a robot from $x$ to the segment containing
%$y$.
%\end{lemma}
%
%\begin{proof}
%By Lemma \ref{def:transition}, each edge in the path from $v_x$ to $v_y$
%describes a family of bounce laws which can take a robot from any point in the
%source edge to a point in the target edge. The transition functions represented
%by these families can be composed together {\color{red} how exactly to do this
%is not clear}
%\end{proof}


%The crux of the algorithm is that we can determine which transitions between
%edges of $P'$ admit intervals of departure angles $\tilde{\theta}$ under which
%\emph{any} point in $e_i$ can transition to \emph{some} point in $e_j$.
%
%Thus, a path in the bounce visibility graph represents the composition of such guaranteed transitions.


%For a sequence of transitions $f_1, \ldots, f_k$,

%$\max_{i \in \{1,\ldots, k\}}( \min(angle\_range(f_i) ))$

%
%We would like to chain together nondeterministic transitions such that each
%transition is guaranteed to land in the "basin" of the next.

%We use pre-image backchaining to determine sequences of edges which might allow
%such transitions, based on visibility properties. This is found through a simple
%breadth-first search through the graph from the goal to the start.

%Then, we must determine strategies which can execute these series of transitions
%from the start interval. This is done using forward projection from the start
%set.

%It is possible that paths without loops may be impossible without
%more precise knowledge of the robot's position than is available (see Case 2 in
%Proposition 2).
%
%There are several methods of dealing with this. We can reduce uncertainty by
%finding a nearby limit cycle and including it in our path, allowing us to
%arbitrarily reduce uncertainty. We can use
%contraction mappings along the way to reduce uncertainty in a similar way.



%\subsubsection{Constant Fixed Angle Controllers}
%
%If we wish to treat the special case of a constant controller $b(\alpha, \theta)
%= \theta$, we could find a strategy as described in Algorithm \ref{algo:nav} and
%then inspect the strategy to see if it admits a constant controller. However,
%this approach is not complete, since a different bounce sequence may allow a
%constant control strategy while than the one found by preimage backchaining.
%
%For a complete (up to bounded length) algorithm, we may incorporate the
%constraint on constant $\theta$ into the search procedure. At each step in the
%backwards search from the goal set, maintain an interval of angles which allow
%all the previously found transitions.


\subsection{Patrolling}

We define the \emph{patrolling} task as:

\begin{quotation}
Given an environment $P$, a set of possible starting states $S$, and
a sequence of edges of the environment $E = \{e_1, \ldots, e_k\}$,
determine a strategy which causes the robot to visit each edge of the sequence
in order on a repeatable path.
\end{quotation}

This task is related to the Aquarium Keeper's Problem in computational
geometry \cite{czyzowicz1991aquarium}.

And a weaker task:

\begin{quotation}
Given an environment $P$, a set of possible starting states $S$, find a limit
cycle reachable from all points in $S$ under the same strategy.
\end{quotation}

Algorithm: finding limit cycles is done by finding cycles in graph with
contraction coefficient less than 1

\begin{definition}
A sequence of transitions $f_1 \circ \ldots \circ f_k$ is \textbf{strongly
contracting} if $\forall i \in \{1, \ldots, k\}, f_i$ is a contraction mapping.
\end{definition}

\begin{corollary}
Every polygon will produce a bounce visibility graph containing at least two
strongly contracting cycles, for $\theta \in [0, \phi_{min}/2]$ and $\theta \in
[\pi - \phi_{min}/2, \pi]$.
\end{corollary}

\begin{proof}

Let the robot have a constant fixed angle bounce strategy, so it always leaves
the boundary at angle $\theta \in [0,\phi_{min}/2]$ counterclockwise from the
boundary.

At each transition, the robot will either strike the next adjacent edge in
$P$, or a reflex vertex will cause the robot to strike some other edge in the
polygon. Either way, the transition is guaranteed to be a contraction mapping by
the definition of $\phi_{min}$ and Lemma \ref{lemma:angrange}.

Eventually, this strategy will produce a strongly contracting cycle. Each
transition moves the robot from one edge to another, so at some point, the
robot's trajectory must return to an edge it has previously visited. The series
of transitions in this trajectory corresponds exactly to a strongly contracting
cycle in the bounce visibility graph.
\qed

\end{proof}

Note that the previous proof does not guarantee a limit cycle in every polygon.
It is possible to construct polygons such that the locations of the collision
points in the stable limit cycle do not all fall within the edges forming the
strongly contracting cycle. However, the only examples of such that we have been
able to construct are in general position and are unlikely to occur in practical
applications.

Note that limit cycles can contain non-contracting bounces, so the number of
possible limit cycles is exponential in $n$.



\subsection{Comparing Bounce Laws}

\begin{remark}
reachability of graph gives ordering on the power of bounce laws
\end{remark}

{\color{red} needs example}




\section{Open Questions and Future Work}

\subsection{Optimal Backprojections for Navigation}

To create a complete navigation algorithm, we 

We have three degrees of freedom when computing action preimages - the angle
interval and the size/location of the subinterval.

There are two natural quantities we may wish to maximize for such a transition -
the size of the subinterval, or the size of the angle interval.
The maximum angle interval will always be a point. Imagine an interval on $e_i$
which allowed for a maximal angle range $[\theta_{min}, \theta_{max}]$ that
guaranteed a transition from any point in the interval to $e_j$. By
shrinking this interval to a point, we must increase the size of the angle
interval, creating a contradiction. The maximum size subinterval will always correspond to a singleton angle range,
$\theta$, such that $l_{sub}$ and $r_{sub}$ are parallel. The location of this
interval will depend on the local geometry.

Case 1: start set is entirely contained within equivalence class

Case 2: start set is split across equivalence classes (make strategies for
subsets of start set and intersect - what kinds of strategy intersections make
sense?)

\subsection{Relative Bounce Law Analysis}

given initial position and orientation, can generate new visibility graph for
all possible relative angles.


\subsection{Localization}

\begin{definition}
A localization strategy is a nondeterministic strategy that produces paths all
ending at the same node, from a starting set.
\end{definition}

Connect to Shell/Alam/Bobadilla work on limit cycles for localization.


We are very interested in using the dynamical properties of this robot model to
create controllers which produce ergodic motion, where the time-averaged
behavior of the system approaches the space-averaged behavior, causing the robot
to not spend ``too much'' time in any given part of the state space. Measures
of ergodicity have recently been used in exploration tasks
\cite{miller2016ergodic}. Chaotic dynamical systems have also been used directly
as controllers for mobile robots \cite{nakamura2001chaotic}.

{\color{red} 
\begin{itemize}
\item characterization of swaths of bounce laws
\end{itemize}
}

%\subsubsection{Incorporating other Sensor Models}
%
%\section{Examples}
%
%\subsection{office space w/ long hallway}
%\subsection{``almost symmetric" environment}
%\subsection{worst case complexity}
%
\iffalse

{\small
\begin{center}
\begin{quotation}
``Geometry is not true, it is advantageous.'' \\
\hfill    --- Henri Poincar\'e
\end{quotation}
\end{center}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Link diagram}

The link distance between two vertices in a polygon is the minimum number of line segments inside the polygon connecting the two vertices. The link distance between visible vertices is $1$. In Fig~\ref{fig:link_dis}, the link distance between $v_1$ and $v_2$ is 3.

The link diagram, as introduced in \cite{tan_sweep}, displays the link distance between any two points on the boundary of the polygon. The link diagram is our main motivation for creating a visibility diagram augmented with bouncing information.
\begin{figure}
    \includegraphics[width=0.6\linewidth]{figures/link_distance.png}
    \centering
    \caption{The link distance between $v_1$ and $v_2$ is 3, as shown by the three blue line segments connecting the two vertices.}\label{fig:link_dis}
    \centering
\end{figure}

\section{Bounce Visibility Diagram \label{bvd_def}}
We will now define the central structure for this paper, the
\textit{Bounce Visibility Diagram} for polygon $P$. We will first insert all new
vertices from the partial local sequence for all vertices into the
polygon $P$, creating the new polygon $P'$ with $m$ vertices. Each of these new
vertices marks a combinatorial change in the visibility polygon at the boundary
of the polygon as an agent traverses the boundary.

The $x-$axis of the diagram parameterizes the boundary of the new polygon,
denoted as $\partial P'$, in counterclockwise order as the interval $[0, m+1)$. The
enpoints of this interval are identified, though for visualization purposes we
do not represent this explicitly. We map every
point in $\partial P'$ to a point in $[0, m+1)$; vertex $v_i$ on $\partial P'$
will map to $x = i$; all points in the open edge $v_iv_{i+1}$ will uniformly map
to $(i, i+1)$. Let $f: [0, m+1)\mapsto \partial P'$ denote this
parameterization. We will generally use the variable $s$ to refer to points on
the boundary of $\partial P'$.

The vertical axis $\theta$ of the diagram has range $[0, \pi]$, representing all
the possible departure angles of the robot from point $s \in \partial P'$. 
At angle $0$, the robot is performing ``wall following": a bounce
to the next counterclockwise vertex.
Let the robot's ``forward direction'' be the direction of the edge that the
robot is on in counterclockwise order.

For each vertex $v_i$, we can define a function $B_i: [0, n) \mapsto [0, \pi]$
for the angle between the robot's forward direction and its direction to vertex
$v_i$ when the robot stands at $f(x)\in \partial P'$. $B_i$ are piecewise
continuous functions; the discontinuities occur when $x$ is an integer, or, in
other words, at the vertices of $\partial P'$. The original vertices in $P$ mark
discontinuities because the angle reference frame for the robot changes when it
moves to a new edge; the new vertices in $P'$ mark discontinuities because the
robot has different vertex visibility view around those vertices, which
motivates us to compute the partial local sequences in the first place.
Fig \ref{fig:bvd} shows an example of the bounce visibility diagram.

%\begin{figure}
%
%\centering
%\begin{subfigure}{0.25\textwidth}
%\centering
%\includegraphics[width=0.7\linewidth]{figures/color_pent.png}
%\captionof{figure}{\label{fig:color_pent}}
%\end{subfigure}%
%\begin{subfigure}{0.25\textwidth}
%\centering
%\includegraphics[width=0.8\linewidth]{figures/bvd.png}
%\end{subfigure}
%\caption{A polygon and its corresponding bounce visibility diagram.}
%\label{fig:bvd}
%\end{figure}



\section{BVD as an Information Space \label{bvd_info}}

Information spaces \cite{tovar2005information} are a useful formalism for
reasoning about the information available to a robot as a result of its sensor
and action history. From the \emph{history information space} (the space of all
sensor/action histories), we can define mappings to other, more useful spaces.

Here we will show that the bounce visibility diagram can induce a useful
information space for many mobile robot tasks, and can be augmented with
information from the geometric properties of actuators and sensors.

We will construct $G_{BVD}$, a graph where nodes are segments in the decomposed
environment $P'$ constructed in Section \ref{bvd_def}.

We then define edges in this graph to be transitions between these segments, based on the bounce laws and
required to transition between them. First, we observe that any two segments in
$P'$ that are visible at all are visible along their entire lengths. Thus, we
there exists a function $f$ which maps a point $s \in v_i
v_{i+1}$ to a point $f(s) \in v_j v_{j+1}$ under a bounce at angle $\theta$ from
the normal on edge $v_i v_{i+1}$, for all valid ranges of $s$, $f(s)$, and
$\theta$.

Rather than use $f$ directly, we take a nondeterministic approach and define a
directed transition between edges $v_i v_{i+1}$ and $v_j v_{j+1}$ if it is
possible to reach edge $v_j v_{j+1}$ from edge $v_i v_{i+1}$ under any bounce.
We label the edge with the range of bounce angles, $\theta_{min} < \theta <
\theta_{max}$, under which this is possible. See Figure \ref{fig:bounce_range} for
the geometric definitions of $\theta_{max}$ and $\theta_{min}$.

\begin{figure}
    \includegraphics[width=0.8\linewidth]{figures/bouncerange.png}
    \centering
    \caption{Definitions of $\theta_{max}$ and $\theta_{min}$. Can be computed
by rotating the source edge to the x axis without loss of generality.}\label{fig:bounce_range}
    \centering
\end{figure}

\subsection{Augmenting the Graph with Dynamical Information}

We can also add information to the edges in $G_{BVD}$ indicating whether the
mapping from one edge to another is a \emph{contraction mapping}: a transition
which will bring two separate points in the domain closer together in the range,
a useful property for reducing state uncertainty and engineering limit cycles,
as will be discussed in Section \ref{patrol}.

The necessary condition for $f$ to be a contraction mapping is:

\begin{equation*}
|f(x) - f(y)| \leq c |x-y|
\end{equation*}

such that $0 \leq c < 1$.

From Figure \ref{fig:cont_map}, we can see that

\begin{equation*}
|f(x) - f(y)| = \frac{\sin(\theta - \phi)}{\sin(\pi-\theta)} |x-y|
\end{equation*}

from the law of sines, where $\phi$ is the angle between the two edges if they
are extended to their intersection point. If the edges are parallel, a
contraction map is not possible (points will maintain their distance, not shrink
closer together). Thus, whenever $\frac{\sin(\theta - \phi)}{\sin(\pi-\theta)}
< 1$, $f$ is a contraction map, and the edge from $v_i v_{i+1}$ to $v_j
v_{j+1}$ can be labelled as such, with the range of $\theta$ which makes this
condition true.

Furthermore, the contraction property of a composition of multiple bounces can
be determined by simply multiplying the coefficients $\frac{\sin(\theta_i -
\phi_i)}{\sin(\pi-\theta_i)}$, and the constraints on the satisfying angles
$\theta_i$ can be propagated through the composition.

\begin{figure}
    \includegraphics[width=0.8\linewidth]{figures/contraction_map_cond.png}
    \centering
    \caption{\label{fig:cont_map}}
\end{figure}

\subsection{Sensor Modelling}

Here we sketch how different virtual sensors may be incorporated into this
information space representation.

\begin{itemize}
\item \emph{Laser Beams:} laser beams form new, internal edges of the polygon. They can be
added to the bounce visibility graph by marking all the edges which represent
bounces that would cross the laser beam with a special symbol. different symbols
for distinguishable beams. If a beam is encountered, and we are tracking state
as a set of possible segments along the boundary of $P'$, we can reduce
uncertainty in our estimate by only propagating the state estimate
forward along edges with that symbol. To engineer reduction in uncertainty,
we may be able to put laser beams in positions that break graph symmetry.
\item \emph{Pebbles:} pebbles are quite important in many robotic tasks, such as
when we need to guarantee that a wall-following strategy has successfully
circumnavigated a polygon. In this representation, we can simply augment nodes
in $G_{BVE}$ if our robot has placed a pebble in that segment (or we may mark
multiple nodes, then use actions to reduce uncertainty in our state estimate
once we return to the pebble).
\item \emph{Cameras:} Especially when discussing coverage, it is helpful to have
some sense of how we "cover" a polygon's interior. One abstract sensor with this
behavior is a model of a camera, which may have some given range and field of
view. The set-theoretic representation of this visibility region can be used to
represent how much of the polygon may be covered by a given trajectory. Ideally,
coverage strategies would allow for satisfying coverage given nondeterminism in
the start states and actions.
\end{itemize}

\section{Task Formulation}

We will now show how to formulate many common robot task specifications in terms
of the data structure described above. The discretization of the continuous
environment allows us to now reason over trajectories through a graph.




\subsection{Patrolling \label{patrol}}

We define the \emph{patrolling} task as:

\begin{quotation}
Given an environment $P$, a set of possible starting states $S$, and
a sequence of edges of the environment $E = \{e_1, \ldots, e_k\}$,
determine a strategy which causes the robot to visit each edge of the sequence
in order on a repeatable path.
\end{quotation}

This task is related to the Aquarium Keeper's Problem in computational
geometry \cite{czyzowicz1991aquarium}.

In prior work \cite{NilBecLav17}, it was shown that stable limit cycles
exist for constant-angle fixed bouncing in regular polygons, for some ranges of bounce angles.
These results also hold for convex polygons in general.

The general flavor of these results are that the bounce functions from edge to
edge are composed into one function which returns the robot to its starting
edge. If this function is a contraction map, a fixed point exists on the
starting edge, and thus a limit cycle of the robot's trajectory exists. The
exact conditions of the existence of this limit cycle depend on the product of
the contraction coefficients being less than one; and on $\theta$ being such
that the bounce at each stage can actually occur. All of the information
necessary to check these conditions is in $G_{BVD}$, as described in Section
\ref{bvd_info}.

Thus, finding all possible limit cycles in an environment $P$ amounts to finding
all cycles in $G_{BVD}$ such that this condition holds.

To examine the behavior of a robot with a given fixed bounce angle, such as the
analysis in \cite{ErLav13}, we can easily extract information for the fixed angle bouncing strategy
mentioned in section \ref{subsec:bounce_strategy} by overlaying an horizontal
line $\theta = \theta_0$ onto the BVD, where $\theta_0$ is the angle chosen by
the bouncing strategy. In Fig \ref{fig:limit_cycle_bvd}, one of the possible
limit cycle with fixed angle $\theta = 0.6$ for the concave quadrilateral is
shown in Fig \ref{fig:limit_cycle}; the bounce visibility diagram for this
polygon is shown in Fig \ref{fig:concave_quad_bvd} with the horizontal line
$\theta = \theta_0$, where $\theta_0 = \frac{\pi}{2}-0.6$ (we need to convert
the angle from w.r.t the normal of the wall to w.r.t the forward direction of
the robot). The horizontal line cut through different regions of the diagram,
representing the possible edges that the robot can bounce to at different points
on the boundary with bounce angle $\theta_0$. For example, at edge $v_5v_0$, the
robot can bounce to edge $v_0v_1$ and $v_1v_2$. We can create a graph for
$\theta = \theta_0$, whose nodes are edges in $P'$ and two nodes are connected
by a directed edge if the robot can bounce from one edge to another at
$\theta_0$, as shown in Fig \ref{fig:limit_cycle_diagram}. It is more stable
for the robot to bounce to some edges than others. In the diagram
(Fig \ref{fig:concave_quad_bvd}), the line $\theta = \theta_0$ cuts through
four different regions for $x \in (2, 3)$, but the sections for $v_4v_5$ and
$v_0v_5$ are much larger than those for $v_0v_1$ and $v_1v_2$. So we know it is
more likely and more stable for the robot to bounce to edge $v_4v_5$ and
$v_0v_5$. We marked the edge with unstable bounce in the graph with $\omega$ in
Fig \ref{fig:limit_cycle_diagram}. The limit cycle shown in
Fig \ref{fig:limit_cycle} corresponds to the cycle
$v_0v_1\rightarrow v_3v_4\rightarrow v_4v_5 \rightarrow v_1v_2 \rightarrow v_2v_3 \rightarrow v_0v_5 \rightarrow v_0v_1$
in Fig \ref{fig:limit_cycle_diagram}.


\begin{figure}
\centering
\begin{subfigure}{0.3\textwidth}
  \includegraphics[width=\linewidth]{figures/simple_nonconv_augmented.png}
  \label{fig:sn1}
\end{subfigure}%
\begin{subfigure}{0.3\textwidth}
  \includegraphics[width=\linewidth]{figures/simple_nonconv_BVD.png}
  \label{fig:sn2}
\end{subfigure}%
\begin{subfigure}{0.3\textwidth}
  \includegraphics[width=\linewidth]{figures/simple_nonconv.jpg}
  \label{fig:sn3}
\end{subfigure}
\caption{\label{fig:sn}}

\end{figure}


\subsection{Localization}

We define the \emph{localization} task as:

\begin{quotation}
Given an accurate map of the environment, but no knowledge of configuration,
determine a strategy which eliminates uncertainty in configuration as much as
possible (ideally, to a point in configuration space).
\end{quotation}

In \cite{OkaLav06}, the authors show that localization is possible with
mobile robots with a linear and angular odometer, or a compass and contact
sensor, but not with robots with only an angular odometer and contact sensor.
These sensing configurations correspond to which types of bounce laws each robot
is capable of performing, and we would like to be able to rederive the same
results in this representation.

Localization amounts to a path finding algorithm in the larger graph, where each
node is an element of the powerset of segments along $P'$. Future work will
include how to tractibly search this graph (such as heuristics for doing so
which take advantage of the uncertainty-reducing properties of contraction
mappings).


\section{Open Questions and Future Work}

If a robot has some guaranteed minimum uncertainty in its actuation, we may
"trim" both ends of each angle interval in the strategy to determine if a "safe"
strategy exists under this actuation uncertainty.


Future work also includes:

\begin{itemize}
\item Characterizing the completeness and correctness of algorithms for
navigation, coverage, localization, etc.
\item Continue to place this work in context, especially with BitBots, Gap
Navigation Trees, and Combinatorial Visibility Vectors
\item Developing ways to query two $G_{BVD}$s, generated with different constraints on
 bouncing laws and sensors, and determine whether one represents a robot which
is ``more powerful" than another. Perhaps this will require a clever
parameterization of bouncing laws.
\item Investigate how to generate bounce law distributions that allow a bounce
to be randomly selected at each stage and guarantee some properties about the
resulting trajectory
\item Extending analysis to more tasks, such as coverage and pursuit-evasion
\end{itemize}


%\begin{tikzpicture}[->,>=stealth,auto,node distance=2.5cm,
%  thick,main node/.style={circle,draw,minimum size = 1.7cm, font=\scriptsize}]
%\node[main node] (x0)   [align=center] {$l_1$\\$x = 0$};
%\node[main node] (x01)  [align=center,below of=x0] {$l_1$\\$0 < x < 1$};
%\node[main node] (x1)   [align=center,below of=x01] {$l_1$\\$x = 1$};
%\node[main node] (x12)  [align=center,below of=x1] {$l_1$\\$1< x < 2$};
%\node[main node] (x2)   [align=center,below of=x12] {$l_1$\\$x = 2$};
%\node[main node] (x23)  [align=center,below of=x2] {$l_1$\\$2<x <3$};
%\node[main node] (x3)   [align=center,below of=x23] {$l_1$\\$x = 3$};
%\node[main node] (x34)  [align=center,below of=x3] {$l_1$\\$3< x < 4$};
%\node[main node] (x4)   [align=center,below of=x34] {$l_1$\\$x = 4$};
%
%\node[main node] (y0)   [align=center,right of=x0] {$l_2$\\$x = 0$};
%\node[main node] (y01)  [align=center,right of=x01] {$l_2$\\$0 < x < 1$};
%\node[main node] (y1)   [align=center,right of=x1] {$l_2$\\$x = 1$};
%\node[main node] (y12)  [align=center,right of=x12] {$l_2$\\$1< x < 2$};
%\node[main node] (y2)   [align=center,right of=x2] {$l_2$\\$x = 2$};
%\node[main node] (y23)  [align=center,right of=x23] {$l_2$\\$2<x <3$};
%\node[main node] (y3)   [align=center,right of=x3] {$l_2$\\$x = 3$};
%\node[main node] (y34)  [align=center,right of=x34] {$l_2$\\$3< x < 4$};
%\node[main node] (y4)   [align=center,right of=x4] {$l_2$\\$x = 4$};
%\node[main node] (y4p)  [align=center,right of=y4] {$l_2$\\$x > 4$};
%
%\path[every node/.style={font=\sffamily\small}]
%     (x0)   edge node [right] {} (x01)
%     (x01)  edge node [right] {} (x1)
%     (x1)   edge node [right] {} (x12)
%     (x12)  edge node [right] {} (x2)
%     (x2)   edge node [right] {} (x23)
%     (x23)  edge node [right] {} (x3)
%     (x3)   edge node [right] {} (x34)
%     (x34)  edge node [right] {} (x4)
%     
%     
%     
%     (y0)   edge node [right] {} (y01)
%     (y01)  edge node [right] {} (y1)
%     (y1)   edge node [right] {} (y12)
%     (y12)  edge node [right] {} (y2)
%     (y2)   edge node [right] {} (y23)
%     (y23)  edge node [right] {} (y3)
%     (y3)   edge node [right] {} (y34)
%     (y34)  edge node [right] {} (y4)
%     (y4)   edge node [right] {} (y4p)
%     (y4p)  edge [loop above] node {} (y4p) 
%     
%     (y1)   edge node [right] {} (x1)
%     (y12)  edge node [right] {} (x12)
%     (y2)   edge node [right] {} (x2)
%     (y23)  edge node [right] {} (x23)
%     (y3)   edge node [right] {} (x3)
%     (y34)  edge node [right] {} (x34)
%     (y4)   edge node [right] {} (x4);
%     
%    \draw [shorten >=1pt,->, smooth] plot coordinates {(x23.west) (-1, -10) (-1,1) (y0.north)};
%    \draw [shorten >=1pt,->, smooth] plot coordinates {(x3.west) (-1.5, -12) (-1.5, 1.5) 
%    (y0.north)};
%    \draw [shorten >=1pt,->, smooth] plot coordinates  {(x34.west) (-2, -14) (-2, 2)
%    (y0.north)};
%    \draw [shorten >=1pt,->, smooth] plot coordinates  {(x4.west) (-2.5, -16) (-2.5, 2.5)
%     (y0.north)};
%
%\end{tikzpicture}

\fi

\bibliographystyle{spmpsci}
\bibliography{refs}

\newpage
\section{Appendix}

\begin{appendix}

\subsubsection{Worst Case Example for Algorithm \ref{algo:insert}}

We might hope that if $r$ is large, then not all of the reflex vertices will
produce a large number of new vertices, and we may bound the size of the edge
set in the visibility graph. Unfortunately, the number of reflex
vertices, the new vertices produced in their partial local sequence, and the new
vertices' visibility can be large at the same time. We will present a family of
input polygons with bounce visibility graph edge-set size of $O(n^4)$.

Let $n = 4t+2$, where $t$ is a positive integer. We design a polygon with
$r = 2t$ reflex vertices. The polygon is symmetric with respect to its medium
horizontal line. In the top half, the reflex vertices are uniformly located on a
circle and thus they are visible to each other; the convex vertices are chosen
so that they are outside the circle and the line through an edge will not
intersect other edges. Each reflex vertex will have at least $t-1$ new
vertices in its partial local sequence. There will be $2t(t-1)+n$
vertices in the polygon after we insert all new vertices in the partial local
sequence for all reflex vertices. Each of them can see at least $t(t-1)+n/2$
other vertices. Thus the number of edges in the transition graph for the
polygon with inserted vertices is
$O ((2t(t-1)+n)(t(t-1)+n/2)) = O(t^4) = O(n^4)$.
Fig \ref{fig:t4} shows the polygon for $t = 4$ with all the
vertices in the partial local sequences. % show the diagram to edge

\begin{lemma} \label{lemma:angrange}
If the transition from segment $e_i$ to segment $e_j$ is a left transition, then the
transition function $f(x, \theta)$ between segments $e_i$ and $e_j$ is a contraction
mapping if and only if $\theta > \frac{\pi}{2}+\frac{\phi_{i, j}}{2}$;
otherwise, the transition function $f(x, \theta)$ is a contraction mapping if
and only if $\theta < \frac{\pi}{2}-\frac{\phi_{i, j}}{2}$.
\end{lemma}
\begin{proof}

\begin{figure}
    \includegraphics[width=1\linewidth]{figures/contraction_map_cond.png}
    \centering
    \caption{The two cases for computing contraction mapping conditions. \label{fig:cont_map}}
    \centering
\end{figure}

We consider the two cases of transition separately:
\begin{enumerate}
    \item For the transition shown in the left hand side of Figure~\ref{fig:cont_map}, 
          \begin{eqnarray*}\overline{xf(x)} \parallel \overline{yf(y)} \Rightarrow \frac{|f(x)-f(y)|}{|x-y|} = \frac{|f(x)|}{|x|} = \frac{\sin(\pi - \theta)}{\sin(\theta - \phi_{i, j})} = \frac{\sin(\theta)}{\sin(\theta-\phi_{i, j})}.\end{eqnarray*} The transition will be contraction if and only if $\frac{|f(x)-f(y)|}{|x-y|} < 1 \iff \sin(\theta)<\sin(\theta-\phi_{i, j})$. If $\theta < \frac{\pi}{2}$, then $\sin(\theta) > \sin(\theta-\phi_{i, j})$. Thus we need $\theta>\frac{\pi}{2}$. If $\theta-\phi_{i, j} > \frac{\pi}{2}$, then $\sin(\theta) < \sin(\theta-\phi_{i, j})$ and we are done; otherwise we need $\pi - \theta < \theta-\phi_{i, j} \Rightarrow \theta - \frac{\phi_{i, j}}{2} > \frac{\pi}{2}$. Combining all conditions, we have the transition will be contraction if and only if $\theta >\frac{\pi}{2} + \frac{\phi_{i, j}}{2}$.
    \item Similarly, for a right transiton shown in the right diagram of figure~\ref{fig:cont_map}, \begin{eqnarray*}\overline{xf(x)} \parallel \overline{yf(y)} \Rightarrow \frac{|f(x)-f(y)|}{|x-y|} = \frac{|f(x)|}{|x|} = \frac{\sin(\pi - \theta)}{\sin(\pi -\theta-\phi_{i, j})} = \frac{\sin(\theta)}{\sin(\theta + \phi_{i, j})}.\end{eqnarray*} The transition will be contraction if and only if $\frac{|f(x)-f(y)|}{|x-y|} < 1 \iff \sin(\theta)<\sin(\theta+\phi_{i, j})$. If $\theta  > \frac{\pi}{2}$, then $\sin(\theta) > \sin(\theta + \phi_{i, j})$. Thus we need $\theta<\frac{\pi}{2}$. If $\theta+\phi_{i, j} < \frac{\pi}{2}$, then $\sin(\theta) < \sin(\theta+\phi_{i, j})$ and we are done; otherwise we need $\theta < \pi-\theta-\phi_{i, j} \Rightarrow \theta < \frac{\pi}{2} - \frac{\phi_{i, j}}{2}$. Combining all conditions, we have the transition will be contraction if and only if $\theta <\frac{\pi}{2} - \frac{\phi_{i, j}}{2}$.
\end{enumerate}
\qed

\begin{figure}
    \includegraphics[width=0.6\linewidth]{figures/convex_cycle.png}
    \centering
    \caption{A supplemental figure to understand the proof of contracting cycle in a convex polygon.\label{fig:conv_cycle}}
    \centering
\end{figure}

\begin{figure}
    \includegraphics[width=0.6\linewidth]{figures/bounce_preimages.pdf}
    \centering
    \caption{An example of how contraction properties can be used to control
robot state uncertainty enough to navigate the robot through a narrow doorway,
even with a lower bound on angle error.}
\label{fig:preimage_example}
\end{figure}


\end{proof}

\end{appendix}

\end{document}
