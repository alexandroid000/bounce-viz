\documentclass[]{styles/svproc}  % Comment this line out

%\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
%\overrideIEEEmargins

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}    % need for subequations
%\usepackage{amsthm}
\usepackage{graphicx}   % need for figures
\usepackage[font=footnotesize,labelfont=footnotesize]{caption}
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
%\usepackage{begin{subfigure} % use for side-by-side figures
\usepackage{subcaption}
\usepackage{hyperref} % use for hypertext links, including those to external documents and URLs
\usepackage{multirow}
\usepackage{rotating}
\usepackage{array}
\usepackage{xspace}
\usepackage{indentfirst}
\usepackage{amssymb}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{comment}
\usepackage{sidecap}
\usepackage{booktabs}

%\newtheorem{theorem}{\bf Theorem}
%\newtheorem{todo}{\bf Todo}
%\newtheorem{remark}{\bf Remark}
%\newtheorem{corollary}{\bf Corollary}
%\newtheorem{definition}{\bf Definition}
%\newtheorem{lemma}{\bf Lemma}
%\newtheorem{proposition}[theorem]{\bf Proposition}

% bounce transition graph
% visibility event graph
% bounce visibility diagram/graph

% synthesis of paths with high-level dynamical properties from simple
% compliant environmental interactions

% skeptical questions:

% - what if the robot starts very near to a boundary of equivalence classes?
% - under what conditions will an *interval* of bounce angles take a robot from
%   one interval to another? With contraction?

% Using Visibility Equivalence Classes for High-Level Dynamical Path Synthesis

% Minimal (Complexity | Attention) Path Synthesis with Dynamical Specifications

%\title{Path Synthesis from Dynamical Specifications \\ for Blind Mobile Robots in Polygons}

% A Toolbox for
\title{A Visibility-Based Approach to Computing Nondeterministic Bouncing
Strategies}
\author{Alexandra Q. Nilles, Yingying Ren, Steven M. LaValle% <-this % stops a space
%\thanks{This work was partially supported by National Science Foundation (award numbers CMMI-1100579 and IIS-1302393).}
}

\institute{University of Illinois at Urbana-Champaign}

\begin{document}


\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Inspired by motion patterns of commercially available mobile robots, we investigate the power of robots that 
move forward in straight lines
until colliding with an environment boundary, at which point they can rotate in
place and move forward again; we visualize this as the robot ``bouncing" off
boundaries. Different boundary interaction laws can be
defined for such robots, such as ones which orient the robot relative to its
heading prior to collision, or relative to the normal vector of the environment
boundary. We introduce a data structure, generated from a polygonal environment
 definition and constraints on the robot's bouncing strategy, which can be
queried to determine the feasibility of path-based tasks such as navigation,
patrolling, coverage, and localization. If the task is feasible, this
approach then synthesizes a controller and calculates the maximum allowable 
uncertainty in the robot's actuation, providing design constraints for different 
environments and tasks.
\end{abstract}

\begin{figure}
    \includegraphics[width=0.8\linewidth]{figures/bounce_examples.pdf}
    \centering
    \caption[test]{\label{fig:bex}Examples of different ``bouncing laws" which can be implemented on
mobile robots. In the first row, $b(\alpha, \theta) = \theta$, which we refer to
as a \textbf{fixed} bounce law. In the second row, we have a \textbf{monotonic
fixed} bounce law, where
$b(\alpha, \theta) = \theta$ or $\pi-\theta$, depending on what is necessary to
preserve monotonicity of travel direction along the $x$-axis. In the third
row, $b(\alpha, \theta) = \alpha - \theta$, rotating $\alpha$ through $\theta$ in the clockwise
direction. It is possible that this rotation will cause the 
heading of the robot to still be facing into the boundary, in which case this model usually has the robot 
perform the rotation again until its heading points into the free space. We
refer to this as a \textbf{relative} bounce law ($\alpha$ appears on the
right hand side of the bounce law).
}
\end{figure}

\section{Introduction}

Mobile robots have rolled smoothly into our everyday lives, and can now be
spotted vacuuming our floors, cleaning our pools, mowing our grass, and moving
goods in our warehouses. These tasks can be formulated as specifications on the
dynamical properties of the robot's path through space: for example, a mowing or
vacuuming robot should cover the space ergodically (informally, it should not visit 
any particular area more frequently than others). A robot which is monitoring
humidity levels in a warehouse, or wireless signals in an office, should follow
a repeatable path (formally, a limit cycle) so that data can be easily compared 
over time.

Current algorithmic approaches to these tasks take two flavors: either
maximizing the information available to the robot though high-fidelity sensors
and map-generating algorithms such as SLAM, or minimizing the information needed
by the robot, such as the largely random navigation strategies of the early
iRobot vacuum models.


% two prongs: beauty of geometry and dynamical systems approach
% and practicality of efficient navigation / patrolling / coverage with mobile
% robots

% current draw gain of regular roomba vs. SLAM- or GPS- enabled roomba?
% would guess at least 10x improvement
% email iRobot people for actual stats?

\section{Model and Definitions}

We consider the movement of point robots in two dimensions, inside simple polygonal
environments. All index arithmetic for polygons with $n$ vertices is mod $n$ 
throughout this paper.

We model robots as points which move forward in straight lines, until encountering 
an environment boundary (such as when a bump or range
sensor is triggered). Once at a boundary, the robot can rotate in place to some
specified angle, either in its local frame or relative to the environment
boundary normal vector, depending on the sensing power of the robot.

Of course, robots rarely move perfectly, so most of our analysis will be
nondeterministic and will result in bounds on how accurate the robot's actuation
is required to be.

More formally, our model includes:

\begin{itemize}
\item The \emph{configuration space} $X = P \times S^1$. $P$ is a simple polygon with 
piecewise linear boundary $\partial P$, and $S^1$ is the robot's orientation in the plane. For the most part, we will ignore configurations in the interior
of the polygon and only consider transitions between points and intervals on the
boundary.
\item The \emph{observation space} $Y$ of sensor readings from sensors that the
robot is equipped with, and the \emph{sensor mapping} $h: X \to Y$ which maps
the robot state to sensor readings. All robot designs in this paper will have at
least a contact sensor, with sensor mapping $h(x) = 1$ if $x \in \partial
P \times S^1$, and $h(x) = 0$ otherwise.
\item The \emph{action space} $U = [0,\pi]$, where $u \in U$ is executed when
the robot is in contact with an environment boundary and rotates to angle $u$
relative to the boundary. $u = \pi/2$ is the normal vector to the boundary.
\item The \emph{state transition function} $f: X \times U \to X$, which
describes how the state of the robot changes according to which action is
chosen. We will often lift this function to act nondeterministically over sets
of states and actions, propagating each state forward with each possible action,
and unioning the resulting set of states.
\item We model time as proceeding in stages, where at each stage $k$ the robot
is in contact with the environment boundary, executes an action $u_k$, and then
moves forward until the next contact with the boundary at stage $u_{k+1}$.
\end{itemize}


\begin{definition}
A \textbf{bounce law} is a specific controller for the robot, which determines
what action the robot will take at a collision with the boundary.
We specify 
bounce laws in the
frame where the environment normal is aligned with the positive $y$ axis and the
robot's point of contact with the wall is the origin.  
Bounce laws are defined as $b: [0,\pi] \times [0,\pi] \to [0,\pi]$, and take as
arguments $\alpha$ (the robot's incoming heading relative to the environment
boundary) and a control parameter $\theta$. See Figure \ref{fig:bex} for some
example bounce laws. 
\end{definition}

\begin{definition}
A \textbf{bounce strategy} is a deterministic finite state machine where each
state indicates a certain (possibly nondeterministic) bounce law, and the input language is that of the
robot's sensor readings.
\end{definition}

Given a polygonal environment (such as the floor plan of a warehouse or office
space), we would like to synthesize bounce strategies which allow a robot to
perform a given task (such as navigation, patrolling, or localization).

\section{Related Work}

The constrained motion model that we use (forward motion until collision,
followed by rotation) is inspired by commercially available robots
for vacuuming, pool cleaning, lawn mowing, and similar applications. It is also
 relevant to the dynamics of some microorganisms - in \cite{microorganism2017}, the authors show that a
\textit{Chlamydomonas reinhardtii} cell would bounce off a surface with a
monotonic fixed angle bounce. This line of work characterizes periodic and
chaotic trajectories in regular polygons, planar curves, and other environments.
They analyze dynamics of fixed bounce angles, without a focus on generating control
strategies. In other dynamical systems literature, other reflection laws have been studied -
the most common is a purely specular reflection law, but contracting laws have
also attracted recent interested \cite{DelMagno2014,billiards,pinball} (no pun intended).


In robotics, 
{\color{red} add todd murphey ergodic paths, and that other ergodic path one steve
found, and the chaotic controller papers}

The most closely related work to ours is \cite{LewOKa13}, which addressed 
the navigation task with a very similar robot
model in polygons. Their robot moves in straight lines until encountering an environment
boundary, at which point it is able to rotate in place, with some nondeterministic but
bounded error. They then generate a strategy as a sequence of bounce angles which can 
navigate the robot between given start and end locations in a known environment. Their approach only allows "safe actions," which place
the entire forward projected state of the robot within a single
linear segment of the polygonal environment. However, this algorithm is
not complete, due to the method used to discretize the environment boundary and
the restriction of only allowing deterministic transitions between boundary
segments. Their navigation graph has $O(n^4)$ nodes, while ours includes only $O(n^2)$
nodes. This approach requires heuristics for searching the graph efficiently,
and also requires hand-crafted local planners for navigating long hallways.

In \cite{alam2017minimalist} and \cite{alam2018space}, the authors describe
navigation, coverage, and localization algorithms for a robot with a clock and
contact sensor that is capable of performing relative angle bounces. Their
approach uses a discretization of the robot configuration space and actuation
space, then searches the discretized dynamical system for limit cycles. The
algorithm is complete and correct up to discretization error - periodic
trajectories may exist which require bounce angles not allowed by the
discretization. By using a discretization induced by the environment geometry, our 
approach considers all possible bounce strategies. {\color{red} explain how to
incorporate constraints on bounce angles here?}

The questions we pose, and our methods of attacking the problem, are related to
work on visibility in computational geometry. Visibility graphs have been
extensively in robotics, but usually in the context of the vertex visibility
graph with the goal of avoiding obstacles {\color{red} add cites}. When we wish
to intentionally use collisions strategically, we require a slightly more
powerful data structure - the edge
visibility graph for a partition of a polygon $P$. The edge visibility graph 
was analyzed along with the vertex-edge visibility graph in \cite{rourke_viz}. {\color{red} they have an
O(n+k) algo for constructing vertex-edge. But correspondence to edge
requires $O(n^2)$ at least - confirm? Also, is this valid w/out general
position? Strong assumption on g.p. in O'Rourke paper}

Our work is also related to lines of questions in computational geometry on what
parts of a polygon will be illuminated by a light source after multiple
reflections (as if the walls of the polygon are mirrors). It has been shown that
the complexity of the region lit in an $n-$gon after $k$ bounces is $O(n^{2k})$
{\color{red} diffuse reflections} \cite{Aronov1996,prasad1998visibility}. In our
notation, this would correspond to the bounce law
$b(\alpha, \theta) = \pi - \alpha$.

We are working toward a generalization and hierarchy of robot models, in a
similar spirit to \cite{brunner2008simple}. Their basic robot model, the simple
combinatorial robot, is able to scan all visible vertices and detect the
presence of an edge between them. It is able to choose a destination vertex and
move in a straight line to that vertex. They then augment this basic robot model
with sensors such as pebbles, angle-measuring devices, and a reflexity detector.
They then construct a hierarchy of these robot models, showing for instance that
some can construct the vertex visibility graph of a polygonal environment
and others cannot. Our questions are related but different - if the robot is
given an environment representation (the vertex-edge visibility graph of a
partitioned polygon), what tasks is it capable of accomplishing?


\section{Outline of Results}

First, we construct a data structure representing possible transitions between points on
the polygon boundary. This data structure can be interpreted as a diagram or graph. 
Each node in the graph (or region in the diagram) corresponds to a segement of the
boundary where the visibility polygon at each point is combinatorially ``the
same." This data structure also encodes information about which transitions are 
uncertainty-reducing.

Then, we show how this data structure can be augmented and queried to solve different
robotic tasks, such as navigation, patrolling, and localization. We also show how this graph can be used to determine the
relative power of robots with different sensor/actuator configurations.

\section{Partitioning Polygons}

Imagine a robot sliding along the polygon boundary, calculating a visibility
polygon as it moves. As it
slides, its visibility polygon changes continuously (edges shrink or grow, but
the combinatorial structure of the polygon remains the same). However, when
the robot, a reflex vertex, and another vertex come into alignment, a
combinatorial change will occur. Either the further vertex will become visible
to the robot, adding an edge to the visibility polygon, or it will become not
visible, removing an edge from the visibility polygon.

To compute all such points where the visibility polygon changes structure, we
must compute the \textbf{partial local sequence}, defined in \cite{rourke_viz}.
The partial local sequence is a sequence of vertices, associated with a vertex
$v_0$ in $P$, such that we shoot a ray through $v_0$ from every vertex in $P$
that is visible from $v_0$ and keep the resulting sequence of intersections with
$\partial P$. If $v_0$ is reflex, some of the rays shot through it may intersect
$\partial P$ in the interior of existing edges. See Figure \ref{fig:pls} for an
example of the vertices in the partial local sequence of $v_0$ (blue dots with
accompanying rays).

Thus, once all the partial local sequences have been inserted into the original
polygon, the resulting intervals along the boundary define a set of equivalence
classes, where two points in the same interval can see the same edge set of the
original polygon (though they may see different portions of those edges). Thus,
we can reason over a finite set of transitions between these intervals, instead
of the infinite set of possible transitions between points on the boundary of
the original polygon.

We now introduce some useful definitions and notation. Let $P'$ be the polygon $P$ with all partial local sequence points inserted.
Let the edge set of $P'$ be $E'$, with $n'$ elements.

\begin{definition}
The \textbf{edge visibility graph} of a polygon $P$ has a node for each edge of
$P$, and has an arc between two nodes $(e_i, e_j)$ if and only if there is a
point $s_i$ in the open edge $e_i$ and a point $s_j$ on the open edge $e_j$ such
that $s_i$ and $s_j$ can be connected with a line segment which is entirely
within the interior of $P$ (the points can ``see" each other).
\end{definition}

Let the \textbf{bounce visibility graph} be the directed edge visibility graph of
$P'$. While visibility is a symmetric property, we use directed edges in this
case so that we can augment each edge with a label function which stores
geometrical constraints on the visibility from one edge to another. This allows
us to make statements such as ``the robot may transition from $e_i$ to $e_j$
from any point on $e_i$ if it departs the edge within angle range
$\tilde{\theta}$."


We now define the \textbf{bounce visibility diagram}. We choose an arbitrary vertex
$v_0$ of $P$ as the origin, and parameterize points $p \in \partial P$ by the
counterclockwise distance from $v_0$, divided by the perimeter length of
$\partial P$. This parameterization defines a bijective function $s: [0,1) \to \partial P$.
We can then use a labelling function $l: \partial P \to [0, \ldots, n']$ to
label each point $p \in \partial P$ with the edge segment in $P'$ that it
belongs to. The graph of the function $f: \partial P \times [0, \pi] \to [0,
\ldots, n']$ is the bounce visibility diagram. See Figures \ref{fig:bvd} and
\ref{fig:regular_pent_bvd} for examples.

\begin{figure}[h]
\centering
\begin{subfigure}{0.4\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/partial_local_sequence.png}
    \caption{Partial local sequence for $v_0$}\label{fig:pls}
\end{subfigure}%
\begin{subfigure}{0.4\textwidth}
    \centering
    \includegraphics[width=\linewidth]{figures/chestnut_5.png}
    \caption{The worst case polygon for $t=4$. \label{fig:t4}}
\end{subfigure}
\end{figure}

\begin{algorithm}
\caption{Partition the boundary of a polygon into visibility
equivalence classes.}
\label{algo:insert}
\begin{algorithmic}
\Procedure{PartitionPoly}{$poly$}
\State $reflex\_verts \gets$ \Call{GetReflexVerts}{$poly$}
\For{$v_r$ in $reflex\_verts$}
    \For{$v_{vis}$ in \Call{VisibleVerts}{$poly, v_r$}} \Comment{vertices
visible from reflex induce transitions}
        \State $v_{new} \gets$ \Call{ShootRay}{$v_{vis}, v_r$}
    \EndFor
\EndFor
\State $partitioned\_poly \gets$ \Call{InsertVerts}{$v_{new}, poly$}
\State \textbf{return} $partitioned\_poly$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{proposition} The bounce transition graph for a polygon with $n$ vertices has 
$O(n^2)$ vertices and $O(n^4)$ edges.
\end{proposition}

\begin{proof}

Consider a polygon $P$ with $n$ vertices, $r$ of which are reflex vertices. To
construct the bounce visibility graph, we insert the vertices of the partial
local sequence for each vertex in $P$. For a convex vertex, its partial local sequence 
will not add any new vertices to $P$. However, a reflex vertex can add $O(n)$ new vertices. 

Up to half of the vertices in the polygon can be reflex, so the complexity of
$r$ is $O(n)$. Therefore, the number of vertices in $P'$, returned by Algorithm
\ref{algo:insert} is $O(n^2)$. Each vertex corresponds to an edge in $P'$, and
thus a node in the edge visibility graph of $P'$. At most, a given vertex in $P'$ may see all other vertices, so in the worst
case, the bounce visibility graph will have $O(n^4)$ edges.

\end{proof}

\subsubsection{Worst Case Example}

We might hope that if $r$ is large, then not all of the reflex vertices will
produce a large number of new vertices, and we may bound the size of the edge
set in the visibility graph. Unfortunately, the number of reflex
vertices, the new vertices produced in their partial local sequence, and the new
vertices' visibility can be large at the same time. We will present a family of
input polygons with bounce visibility graph edge-set size of $O(n^4)$.

Let $n = 4t+2$, where $t$ is a positive integer. We design a polygon with
$r = 2t$ reflex vertices. The polygon is symmetric with respect to its medium
horizontal line. In the top half, the reflex vertices are uniformly located on a
circle and thus they are visible to each other; the convex vertices are chosen
so that they are outside the circle and the line through an edge will not
intersect other edges. Each reflex vertex will have at least $t-1$ new
vertices in its partial local sequence. There will be $2t(t-1)+n$
vertices in the polygon after we insert all new vertices in the partial local
sequence for all reflex vertices. Each of them can see at least $t(t-1)+n/2$
other vertices. Thus the number of edges in the transition graph for the
polygon with inserted vertices is
$O ((2t(t-1)+n)(t(t-1)+n/2)) = O(t^4) = O(n^4)$.
Fig \ref{fig:t4} shows the polygon for $t = 4$ with all the
vertices in the partial local sequences. % show the diagram to edge


\begin{figure}

\centering
\begin{subfigure}{0.35\textwidth}
\centering
\includegraphics[width=0.7\linewidth]{figures/color_pent.png}
\captionof{figure}{\label{fig:color_pent}}
\end{subfigure}%
\begin{subfigure}{0.35\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{figures/bvd.png}
\end{subfigure}
\caption{A polygon and its corresponding bounce visibility diagram.}
\label{fig:bvd}
\end{figure}

\begin{figure}
\centering
\begin{subfigure}{0.35\textwidth}
\centering
\includegraphics[width=0.5\linewidth]{figures/regular_pent.png}
\end{subfigure}%
\begin{subfigure}{0.35\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{figures/regular_pent_bvd.png}
\end{subfigure}
\caption{The bounce visibility diagram for the regular pentagon. }
\label{fig:regular_pent_bvd}
\end{figure}

\section{Tasks}

Many tasks required of mobile robots can be specified in terms of properties of
the path the robot takes through space. \emph{Navigation} requires a path that
begins and ends in specified regions; \emph{patrolling} requires a repeatable
path that satisfies some coverage criterion; \emph{localization} requires a path
which reduces uncertainty in the robot's position.

Once we have partitioned the polygonal environment and constructed the resulting
edge visibility graph, we can establish relations between properties of
paths in the graph and paths of the robot in the actual environment.

\begin{definition}\label{def:transition}
For edge $e_{ij} \in E(G)$, for each point $x$ in the segment $i$, there 
exists a range of angles $\tilde{\theta}$ such that $f(x,\theta) \in j$ for
some $\theta \in \tilde{\theta}$.
\end{definition}

\begin{proof}
By construction, edge $e_{ij}$ exists if and only if there is a point $x$ on the (open)
segment $i$ and a point $y$ on the (open) segment $j$ such that $x$ and $y$ are
visible to each other. Since $y$ is in the open segment, there will always be some $\epsilon$-neighborhood around
$y$ which is also visible from $x$, and the endpoints of this
$\epsilon$-neighborhood define a range of angles at which the robot may leave
$x$ and arrive on segment $j$.

This angle range can be constructed through simple trigonometry for a
given point and target segment.
\end{proof}

A generally useful property of transitions between boundary segments is when the
transition is a \emph{contraction mapping}: two points, when mapped through the
transition, always become closer together. We will use this property to control
uncertainty in the robot's position, and to engineer stable limit cycles in
Section \ref{sec:cycles}.


\begin{definition} \label{def:angrange}
Given two mutually visible segments $i,j \in \partial P$, there exists a range 
of angles from which a transition from $i$ to $j$ is possible from from some
point in $i$ to some point in $j$.
See Figure \ref{fig:bounce_range}. This interval, $[\theta_{min}, \theta_{max}]$, 
is the union of the point-wise angle intervals described in Definition
\ref{def:transition}.
\end{definition}

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{figures/bouncerange.png}
    \caption{Definitions of $\theta_{max}$ and $\theta_{min}$. Can be computed
by rotating the source edge to the x axis without loss of generality.}
\label{fig:bounce_range}
\end{figure}

\begin{definition}
Let $\phi_{ij}$ be the interior angle between two segments $i$ and $j \in
\partial P$ if they are extended 
to infinity. The case where the segments are parallel will be handled separately
where necessary.
\end{definition}

\begin{lemma} \label{lemma:angrange}
The transition function $f(x, \theta)$ between
 segments $i$ and $j$ is a contraction mapping if and only if $\phi_{ij}/2 < \theta < \pi$ or $0 < \theta
< \phi_{ij}/2$.
\end{lemma}

\begin{proof}
The necessary condition for $f$ to be a contraction mapping is:

\begin{equation*}
|f(x) - f(y)| \leq c |x-y|
\end{equation*}

such that $0 \leq c < 1$.

\begin{figure}
    \includegraphics[width=0.5\linewidth]{figures/contraction_map_cond.png}
    \centering
    \caption{A diagram showing how the condition for a contraction mapping is
calculated. \label{fig:cont_map}}
    \centering
\end{figure}

From Figure \ref{fig:cont_map}, we can see that

\begin{equation*}
|f(x) - f(y)| = \frac{\sin(\theta - \phi)}{\sin(\theta)} |x-y|
\end{equation*}

from the law of sines, where $\phi$ is the angle between the two edges if they
are extended to their intersection point. If the edges are parallel, a
contraction map is not possible (points will maintain their distance, not shrink
closer together). Thus, whenever $| \frac{\sin(\theta - \phi)}{\sin(\theta)}
| < 1$, $f$ is a contraction map, and the edge from $v_i v_{i+1}$ to $v_j
v_{j+1}$ can be labelled as such, with the range of $\theta$ which makes this
condition true.

\end{proof}

Let $C(\theta, \phi) = | \frac{\sin(\theta - \phi)}{\sin(\theta)} |$.

For a sequence of bounces $b_1, \ldots, b_k$, we can construct the overall
mapping from the domain of $b_1$ to the range of $b_k$ through function
composition. Since $f$ is a linear mapping, the contraction property of a composition 
of multiple bounces can be determined by multiplying the coefficients $C(\theta, \phi)$, 
and the constraints on the angle range $\tilde{\theta}$ can be propagated through the 
composition by intersecting the angle intervals.

If $\prod_{i=1}^k C(\theta_i, \phi_i) < 1$, the composition of bounces $b_1, \ldots, b_k$
is a contraction mapping. This is true even if some transition $b_i$ is not a
contraction mapping, since the coefficient is simply the ratio of distances
between points before and after the mapping is applied.

\subsection{Navigation}

\begin{definition}
\textbf{Navigation}:
Given a polygonal environment $P$, a start set of possible robot positions along the
environment boundary $S$, and a goal set $G$, determine a strategy $\pi$ which
will be guaranteed to take the robot from any point in $S$ to a point in $G$, or
determine that no such strategy exists.
\end{definition}

\begin{lemma}
Given $\Pi$, a non-overlapping partition of the environment boundary $\partial P$, and the resulting edge-to-edge visibility graph
$G$, and points $x,y \in \partial P$, let $v_x \in V(G)$ be the node representing
the segment in $\Pi$ that contains $x$, and $v_y$ be the node corresponding to
the segment containing $y$. Then, a path in $G$ from $v_x$ to $v_y$ corresponds
to a family of strategies which take a robot from $x$ to the segment containing
$y$.
\end{lemma}

\begin{proof}
By Lemma \ref{def:transition}, each edge in the path from $v_x$ to $v_y$
describes a family of bounce laws which can take a robot from any point in the
source edge to a point in the target edge. The transition functions represented
by these families can be composed together under normal function composition.
{\color{red} describe how domain/range overlap is computed - interval propagation}
\end{proof}

\begin{definition}
Two line segements $i$ and $j$ are \emph{entirely visible} to each other iff
every pair of points $x \in i$ and $y \in j$ are visible.
\end{definition}

\begin{proposition}
Given two entirely visible line segments $i$ and $j$, and a connected subset
$i_{sub} \subseteq i$, it is possible to compute the maximum range of angles 
$[\theta_{min}, \theta_{max}]$ such that $f(s, \theta) \in j$, for all $s \in
i_{sub}$ and for all $\theta \in [\theta_{min}, \theta_{max}]$, or we may
compute that no such range exists.
\end{proposition}

\begin{proof}
Let segment $i$ be aligned with the $x$ axis, without loss of generality.

Take the quadrilateral formed by segments $i$, $j$, and the non-crossing line
segments connecting their endpoints (the convex hull of the segment endpoints).
Call the left-hand segment $l$ and the right-hand segment $r$.

Let $\theta_{l}$ be
the angle between $l$ the positive $x$ axis ($0 < \theta_l < \pi$); similarly
for $r$ and $\theta_r$. Let $\theta_{min} = \min(\theta_r, \theta_l)$ and
$\theta_{max}$ be the larger of the two.

There are three cases to consider: if $l$ and $r$ are extended to infinity,
they cross either above or below segment $i$, or they are parallel.

\emph{Case 1:} $l$ and $r$ would meet below segment $i$. Let 
Then, if a ray is cast from any point on $i$ at angle $\theta$ such that $\theta_{min} <
\theta < \theta_{max}$, the ray is guaranteed to intersect $j$ in its interior.
Also, $\theta_l = \theta_{max}$, and $\theta_r = \theta_{min}$.

\emph{Case 2:} $l$ and $r$ would meet above segment $i$. There is no angle
$\theta$ such that a ray shot from \emph{any} point on $i$ will intersect $j$.

\emph{Case 3:} $l$ and $r$ are parallel. This implies that $\theta_{min} =
\theta_{max} = \theta$, which is the only angle for which a transition from any
point on $i$ is guaranteed to intersect $j$.

Thus, for each case, we can either compute the maximum angle range or determine
that no such angle range exists.
\end{proof}

Note that when we compute pre- and post-images of transitions under our robot
model, only cases 1 and 3 apply: either the robot bounces at a singleton angle
or a range of angles. 

The crux of the algorithm is that from each arc $e_{ij}$ in $BVG$, we can compute
intervals of departure angles $\tilde{\theta}$ under which \emph{any} point in
$e_i$ can transition to \emph{some} point in $e_j$. Thus, a path in $BVG$
represents the composition of such guaranteed transitions.

If a robot has some guaranteed minimum uncertainty in its actuation, we may
"trim" both ends of each angle interval in the strategy to determine if a "safe"
strategy exists under this actuation uncertainty.

\begin{algorithm}
\caption{Generating a nondeterministic bounce strategy for navigation from any
point in start set $S$ to a point in goal set $G$.}
\label{algo:nav}

\begin{algorithmic}
\Procedure{Navigate}{$poly$, $G$, $S$, $criterion$}
\State $BVD \gets$ \Call{PartitionPoly}{$poly$, $G$, $S$}
\State $paths \gets$ \Call{BFS}{$BVD$, $G$, $S$}
\State $strategies \gets$ \Call{getStrategies}{$paths$}
\State \Return \Call{argmax}{strategies, \textsc{getAngInt}}
\EndProcedure
\end{algorithmic}
\end{algorithm}

For a sequence of transitions $f_1, \ldots, f_k$,

$\max_{i \in \{1,\ldots, k\}}( \min(angle\_range(f_i) ))$


We would like to chain together nondeterministic transitions such that each
transition is guaranteed to land in the "basin" of the next.

given start interval, compute maximum-angle interval transitions to all visible
edges

then do BFS from goal set in this constrained graph back to the start interval

could be multiple paths with same number of bounces that get to goal set

reachability vs. guaranteed-along-all-paths

We have three degrees of freedom when computing action preimages - the angle
interval and the size/location of the subinterval.

There are two natural quantities we may wish to maximize for such a transition -
the size of the subinterval, or the size of the angle interval.
The maximum angle interval will always be a point. Imagine an interval on $i$
which allowed for a maximal angle range $[\theta_{min}, \theta_{max}]$ that
guaranteed a transition from any point in the interval to $j$. By
shrinking this interval to a point, we must increase the size of the angle
interval, creating a contradiction. The maximum size subinterval will always correspond to a singleton angle range,
$\theta$, such that $l_{sub}$ and $r_{sub}$ are parallel. The location of this
interval will depend on the local geometry.

\subsubsection{Constant Fixed Angle Controllers}

For constant angle controllers, this
ends up being a coupled problem - want to chain together preimages such that
\emph{overall} angle range is as large as possible.

\textbf{In Convex Polygons}

\textbf{Definitions.}
If a limit cycle inside a convex polygons with $n$ edges forms another convex polygon with $n$ edges, we call this limit cycle as convex $n$-cycle.

\begin{definition}
$\phi_{P,min}$ is the smallest interior angle in a polygon $P$. We will omit the
label $P$ when it is clear from context.
\end{definition}

\begin{theorem} \label{thm:convex}
For all convex polygons with $n$ edges, there exists a range for $\theta$ such that fixed-angle bouncing strategy with $\theta$ will lead to a convex $n$-cycle regardless of the robot's start position.
\end{theorem}
\begin{proof}
Without loss of generality, assume $\theta \in (0, \frac{\pi}{2}]$. Consider the
triangle formed by two adjacent edges $e_i$, $e_{i+1}$ of $P$. The robot will
bounce from $e_i$ to $e_{i+1}$ regardless of its start position if and only if
$\theta \in (0, \angle v_{i+2}v_{i}v_{i+1})$. Thus, the robot will always bounce
to the next adjacent edge if and only if
$\theta \in (0, \min_{i}(\angle v_{i+2}v_{i}v_{i+1})$.

Suppose we have two start positions $x$ and $y$ on edge $e_0$ and the two
corresponding trajectories under fixed angle $\theta$. Denote the robot's
position on $e_k$ after bouncing $k$ consecutive edges as $f^{k}(x)$ and
$f^{k}(y)$ respectively. $\triangle f^{k}(x)v_{k+1}f^{k+1}(x)$ and
$\triangle f^{k}(y)v_{k+1}f^{k+1}(y)$ are similar triangles since they share a
common internal angle of the polygon, $\pi - \phi_{k,k+1}$, and the bouncing angle
$\theta$.

The distance between the two trajectories on $e_0$ after the robot bounces off
every edge of the polygon, i.e., bounces off $n$ times, is
$d(f^{n}(x), f^{n}(y))$.

Since function composition multiplies the coefficients $C(\theta, \phi)$, 
the distance between $x$ and $y$ changes after one orbit of the polygon by the
ratio

\begin{eqnarray*}
\frac{d(f^{n}(x)), f^{n}(y))}{d(f^{0}(x), f^{0}(y))} = \prod_{i = 0}^{n-1}
C(\theta, \phi_{i}).
\end{eqnarray*}

If $\prod_{i = 0}^{n-1} C(\theta, \phi_{i}) < 1$, then $f^k(x)$ is a contraction
mapping from $e_0$ back to iteself, and by the Banach fixed-point theorem, it
has a unique fixed point \cite{Granas2003}.

The constraint $C(\theta,\phi_{i})<1$ is equivalent to
$\theta < \frac{\phi_{i}}{2}$. So we can guarantee that this condition holds
for the orbit by requiring

\begin{equation*}
\theta \in (0, \min(\min_{i = 0, 1, \dots, n-1}(\angle v_{i+2}v_{i}v_{i+1}),
\frac{\phi_{P,min}}{2})),
\end{equation*}

in which case the fixed-angle bouncing strategy with $\theta$ leads to a convex
$n$-cycle regardless of the robot's start position.
\end{proof}

Remarks:
\begin{enumerate}
    \item We can analyze the case for $\theta \in [\pi/2, \pi)$ by symmetry.
    \item To get the range of all possible $\theta$ that will lead to a limit cycle tangent to each edge of the polygon sequentially, we can solve for $|\Pi_{i = 0}^{n-1}\frac{\sin(\theta)}{\sin(\Phi_{i}-\theta)}|<1$ and then intersect the result with (0, $\min_{i}(\angle v_{i+2}v_{i}v_{i+1})$.
\end{enumerate}





\subsubsection{Constant Relative Angle Controllers}

given initial position and orientation, can generate new visibility graph for
all possible relative angles.

\subsection{Patrolling \label{sec:cycles}}


\begin{proposition}
Every convex polygon admits a limit cycle, under a fixed-angle bounce law, 
which visits each edge in cyclic order.
\end{proposition}

\begin{proof}

For each consecutive pair of edges of the polygon, $e_i$ and $e_{i+1}$, let
$\phi_i$ be the interior angle between them. By Lemma \ref{lemma:angrange}, the
transition function $f_i$ from edge $e_i$ to edge $e_{i+1}$ will be a
contraction mapping for all $\theta$ such that $0 < \theta < \phi_i/2$.


\end{proof}

\begin{definition}
Call a sequence of transitions $f_1 \circ \ldots \circ f_k$ \textbf{strongly
contracting} if $\forall i \in \{1, \ldots, k\}, f_i$ is a contraction mapping.
\end{definition}

\begin{corollary}
Every polygon will produce a bounce visibility graph containing at least two
strongly contracting cycles, for $\theta \in [0, \phi_{min}/2]$ and $\theta \in
[\pi - \phi_{min}/2, \pi]$.
\end{corollary}

\begin{proof}

Let the robot have a constant fixed angle bounce strategy, so it always leaves
the boundary at angle $\theta \in [0,\phi_{min}/2]$ counterclockwise from the
boundary.

At each transition, the robot will either strike the next adjacent edge in
$P$, or a reflex vertex will cause the robot to strike some other edge in the
polygon. Either way, the transition is guaranteed to be a contraction mapping by
the definition of $\phi_{min}$ and Lemma \ref{lemma:angrange}.

Eventually, this strategy will produce a strongly contracting cycle. Each
transition moves the robot from one edge to another, so at some point, the
robot's trajectory must return to an edge it has previously visited. The series
of transitions in this trajectory corresponds exactly to a strongly contracting
cycle in the bounce visibility graph.

\end{proof}

Note that the previous proof does not guarantee a limit cycle in every polygon.
It is possible to construct polygons such that the locations of the collision
points in the stable limit cycle do not all fall within the edges forming the
strongly contracting cycle. However, the only examples of such that we have been
able to construct are in general position and are unlikely to occur in practical
applications.

\begin{lemma}
cycles can contain non-contracting bounces - there are lots of cycles
\end{lemma}


\begin{theorem}
cycle-finding algorithm is sound, complete up to bounded length
\end{theorem}

\begin{proof}
make graph, quotient so that non-contraction edges are removed / edge conditions
are modified appropriately

then find cycle basis
\end{proof}

Example: using cycles to arbitrarily control uncertainty


Patrolling synthesis algorithm: given periodic sequence of edges, return a controller that
results in a stable limit cycle that visits those edges in that sequence.

What if we can insert edges into the sequence?

\subsection{Localization}

\begin{definition}
A localization strategy is a nondeterministic strategy that produces paths all
ending at the same node, from a starting set.
\end{definition}

\begin{theorem}
localization is correct and complete up to symmetry ("splitting" angle ranges
will always exist if and only if symmetry is broken)
\end{theorem}


\section{Extensions}

\begin{corollary} bounce angle range returned is correct, and optimal
   (largest range)
\end{corollary}

\begin{theorem}
reachability of graph gives ordering on the power of bounce laws
\end{theorem}

\subsection{Localization}

\subsubsection{Incorporating other Sensor Models}

\section{Examples}

\subsection{office space w/ long hallway}
\subsection{``almost symmetric" environment}
\subsection{worst case complexity}

\iffalse

{\small
\begin{center}
\begin{quotation}
``Geometry is not true, it is advantageous." \\
\hfill    --- Henri Poincar\'e
\end{quotation}
\end{center}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} 

This control strategy is largely chosen because of the ease of implementation.
It requires much less fine-grained proprioception than many other mobile robot
control algorithms, needing the robot to only have the ability to move forward
until reaching some obstacle, then the ability to rotate in place. We assume
from the beginning that there will be nondeterministic error in both of these
operations - especially when wheels are independently powered, robots rarely
move forward in truly straight lines, and rotation-in-place is similarly
difficult to achieve precisely. Both of these types of error are accounted for
by our nondeterministic state propagation. In fact, our approach does not assume
a fixed error distribution or range, but in fact produces the maximum allowable
error values constructively. Thus, this work lends itself well to the mobile
robot system design process - users can iteratively design environments and
robots such that the desired task has a strong guarantee of success.

The only type of error we do not
account for is ``sliding" along the environment boundaries, which may occur
during rotation or collision. However, many common commercial mobile robots
(such as vacuum robots) do not experience appreciable sliding.

% There has been rising interests in minimum sensing robots in recent years as swarm robots become more and more popular. 
In this paper, we consider simple robots with "bouncing" behaviors: robots which
travel in straight lines in the plane, until encountering an environment
boundary, at which point they rotate in place and set off again. A growing line
of work is considering the computational power of individual bouncing strategies
and their applications to robotic tasks and applications in biological contexts
\cite{ErLav13}, \cite{microorganism2017}, \cite{alam2017minimalist}.

We introduce a combinatorial, visibility-based data structure to organize and
compare these bouncing strategies in simple polygonal environments. The overall
idea is to discretize the environment boundary using visibility information,
creating equivalence classes (segments along the boundary) where the robot has a
similar set of choices from any point in the segment. We then construct a graph
representation of this environment where nodes are segments of the boundary, and
edges are transitions between segments (with associated control strategies). We
then extend previous results on the dynamics of composed transitions
\cite{NilBecLav17}, which give convenient guarantees on the stability of cycles
and contraction of robot state uncertainty. Finally, we demonstrate how to
formulate many common mobile robotic tasks as queries to this data structure.


\subsection{Robot Motion Model}\label{subsec:bounce_strategy}

A polygon is in general position if no $3$ vertices lie on the same line. For
the rest of this paper, we assume all polygons are in general position. All
index arithmetic is $\mod n$ throughout the paper.

A \textbf{bouncing strategy} describes the robot's configuration change when it
encounters the boundary of a polygon. We will only consider the bounce occurred
inside an open edge of the polygon: the robot's behavior is undefined at a
vertex of the polygon.

A bouncing strategy defines a function space, where each function maps between 
points of the environment boundary, parameterized by the incoming trajectory
angle and optionally an angle $\theta$.

%Each bouncing strategy has a characterization function
%for $\vec{m}$ over parameters $\vec{n}$ and $\vec{l}$, where $\vec{n}$ is the
%unit vector for the normal of the bounce-off wall, $\vec{l}$ is the unit vector
%for the incoming direction, and $\vec{m}$ is the unit vector for the outgoing
%direction.
%
%\begin{itemize}
%    \item Specular Bounce (Billiard): $\vec{m} = f(\vec{l}, \vec{n})$, where \begin{eqnarray*}
%    f(\vec{l}, \vec{n}) = \vec{l} - 2(\vec{l}\cdot \vec{n})\vec{n}
%    \end{eqnarray*}
%    (``$\cdot$'' is the dot product operation between two vectors), which is equivalent to $(\vec{l}+\vec{m}) \cdot \vec{n} = 0$. This bouncing behavior is elastic and follows the most natural law: the incoming angle equals the outgoing angle \cite{geometry_billards}.
%    \item Fixed Angle Bounce: $\vec{m} = f(\vec{n}, \theta)$, where $\theta$ is a constant in $[-\frac{\pi}{2}, \frac{\pi}{2}]$, and \begin{eqnarray*}f(\vec{n}, \theta) = 
%    \begin{bmatrix} 
%    \cos(\theta) & \sin(\theta)\\
%    -\sin(\theta) & \cos(\theta)\\
%    \end{bmatrix}\vec{n}.\end{eqnarray*} In other words, the robot always bounces off the wall at a fix angle with respect to the normal.
%    \item Monotonic Fixed Angle Bounce: $\vec{m} = f(\vec{l}, \vec{n}, \theta)$, where $\theta$ is a constant in $(0, \frac{\pi}{2})$. Let $s = det(\begin{bmatrix} 
%    \vec{l}.x & \vec{l}.y\\
%    \vec{n}.x & \vec{n}.y\\
%    \end{bmatrix})$, and $\theta' = \frac{s}{|s|}\theta$ ($|s|$ denote the absolute value of $s$; the behavior for $|s| = 0$ is undefined). Then \begin{eqnarray*}f(\vec{l}, \vec{n}, \theta) = 
%    \begin{bmatrix} 
%    \cos(\theta') & \sin(\theta')\\
%    -\sin(\theta') & \cos(\theta')\\
%    \end{bmatrix}\vec{n}.\end{eqnarray*} This bouncing strategy is very similar to the Fixed Angle Bounce except for the monotonic restriction that the robot's incoming path and outgoing path have to be on the opposite sides of the normal.
%    
%    \item Relative Angle Bounce: $\vec{m} = f(\vec{l}, \beta)$, where $\beta$ is a constant in $[0, 2\pi)$, and \begin{eqnarray*}f(\vec{l}, \beta) = \begin{bmatrix}
%    \cos(\beta) & -\sin(\beta)\\
%    \sin(\beta) & \cos(\beta)\\
%    \end{bmatrix}\vec{l}.
%    \end{eqnarray*} The robot will rotate a fixed angle $\beta$ counter-clockwise when encountering the wall. It is possible that this rotation will cause the heading of the robot to still be facing into the wall, in which case this model usually has the robot perform the rotation again until it's heading points into the free space.
%\end{itemize}

% fixed vs. monotonic fixed vs. relative vs. specular

% parameterization for monotonic bounces: alpha + beta + gamma = pi

% all bounces are some function of incoming angle and wall normal

\subsection{Related Work}


The \textit{vertex visibility graph} $G_V(P) = (V, E)$ has $V = \{v_0, v_1, \ldots, v_{n-1}\}$ and $v_iv_j\in E$ if and only if the segment connecting $v_i$ and $v_j$ is completely contained in the interior of $P$. We call $v_i, v_j$ visible to each other if $v_iv_j\in E$. By definition, the vertex visibility graph for a convex polygon with $n$ vertices is a $n-$clique. Fig
\ref{fig:vvg} shows the visibility graph for a non-convex polygon.

\begin{figure}
    \includegraphics[width=0.8\linewidth]{figures/viz_graph.png}
    \centering
    \caption{The vertex visibility graph}\label{fig:vvg}
    \centering
\end{figure}

We can also define the \textit{vertex-edge visibility graph} for a polygon.
Using the definition in \cite{rourke_viz}, the
\textit{vertex-edge visibility graph} for $P$, $G_E(P) = (V, E)$, is a bipartite
graph where $V = \{\text{all vertices and edges in $P$}\}$ and $v_ie_j\in E$ if
and only if $v_i$ can see the interior of $e_j$, i.e., $\exists$ point $q$ on
the open edge $e_j$ such that $v_i$ and $q$ are visible. \cite{rourke_viz}
established that the vertex-edge visibility graph is equivalent to the edge
visibility graph.

Fig \ref{fig:veg} shows an example for vertex-edge visibility graph.

\begin{figure}
\centering
\begin{subfigure}{0.25\textwidth}
  \includegraphics[width=0.6\linewidth]{figures/concave_pent.png}
  \label{fig:c_p}
\end{subfigure}%
\begin{subfigure}{0.25\textwidth}
  \includegraphics[width=0.8\linewidth]{figures/viz_edge_graph.png}
\end{subfigure}
\caption{A polygon and its corresponding vertex-edge visibility graph.\label{fig:veg}}

\end{figure}




\subsection{Link diagram}

The link distance between two vertices in a polygon is the minimum number of line segments inside the polygon connecting the two vertices. The link distance between visible vertices is $1$. In Fig~\ref{fig:link_dis}, the link distance between $v_1$ and $v_2$ is 3.

The link diagram, as introduced in \cite{tan_sweep}, displays the link distance between any two points on the boundary of the polygon. The link diagram is our main motivation for creating a visibility diagram augmented with bouncing information.
\begin{figure}
    \includegraphics[width=0.6\linewidth]{figures/link_distance.png}
    \centering
    \caption{The link distance between $v_1$ and $v_2$ is 3, as shown by the three blue line segments connecting the two vertices.}\label{fig:link_dis}
    \centering
\end{figure}

\section{Bounce Visibility Diagram \label{bvd_def}}
We will now define the central structure for this paper, the
\textit{Bounce Visibility Diagram} for polygon $P$. We will first insert all new
vertices from the partial local sequence for all vertices into the
polygon $P$, creating the new polygon $P'$ with $m$ vertices. Each of these new
vertices marks a combinatorial change in the visibility polygon at the boundary
of the polygon as an agent traverses the boundary.

The $x-$axis of the diagram parameterizes the boundary of the new polygon,
denoted as $\partial P'$, in counterclockwise order as the interval $[0, m+1)$. The
enpoints of this interval are identified, though for visualization purposes we
do not represent this explicitly. We map every
point in $\partial P'$ to a point in $[0, m+1)$; vertex $v_i$ on $\partial P'$
will map to $x = i$; all points in the open edge $v_iv_{i+1}$ will uniformly map
to $(i, i+1)$. Let $f: [0, m+1)\mapsto \partial P'$ denote this
parameterization. We will generally use the variable $s$ to refer to points on
the boundary of $\partial P'$.

The vertical axis $\theta$ of the diagram has range $[0, \pi]$, representing all
the possible departure angles of the robot from point $s \in \partial P'$. 
At angle $0$, the robot is performing ``wall following": a bounce
to the next counterclockwise vertex.
Let the robot's ``forward direction'' be the direction of the edge that the
robot is on in counterclockwise order.

For each vertex $v_i$, we can define a function $B_i: [0, n) \mapsto [0, \pi]$
for the angle between the robot's forward direction and its direction to vertex
$v_i$ when the robot stands at $f(x)\in \partial P'$. $B_i$ are piecewise
continuous functions; the discontinuities occur when $x$ is an integer, or, in
other words, at the vertices of $\partial P'$. The original vertices in $P$ mark
discontinuities because the angle reference frame for the robot changes when it
moves to a new edge; the new vertices in $P'$ mark discontinuities because the
robot has different vertex visibility view around those vertices, which
motivates us to compute the partial local sequences in the first place.
Fig \ref{fig:bvd} shows an example of the bounce visibility diagram.

\begin{figure}

\centering
\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.7\linewidth]{figures/color_pent.png}
\captionof{figure}{\label{fig:color_pent}}
\end{subfigure}%
\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{figures/bvd.png}
\end{subfigure}
\caption{A polygon and its corresponding bounce visibility diagram.}
\label{fig:bvd}
\end{figure}


\subsection{Properties of BVD}
The bounce visibility diagram can generate the vertex visibility graph by
construction. In \cite{rourke_viz}, the authors point out that if the robot can
see a vertex, then it can see the two edges connected to that vertex if the
vertex is convex; otherwise, it can see one of the edges connected to that
vertex. As the robot moves along an edge in the original $P$, its vertex
visibility view changes, as shown for $x\in (3, 6)$ in Fig\~\ref{fig:bvd}. The
region between curve 2 (blue) and curve 7 (red) is subdivided as the $x$
increases, which corresponds to the robot has increasing knowledge about things
behind the gap between vertices $v_2$ and $v_7$ as it moves along the edge
$v_3v_6$: the appearance of gap between vertices $v_1$ and $v_8$, and the
appearance of vertex $v_0$. For $x\in (6, 9]$, the diagram shows a reverse
process of disappearance of gaps. By incorporating the information of the
appearance and disappearance of gaps, we can also generate the vertex-edge
visibility graph from the bounce visibility diagram.
% (\textcolor{red}{I don't have proof yet but I think there are enough info to do that. We can also shift this part about gap navigation into later sections.})

Circular symmetries in a polygon can be reflected in the periodic structure of
the corresponding BVD, as shown in Fig\~\ref{fig:regular_pent_bvd}.

\begin{figure}
% \makebox[\linewidth][c]{%
\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.5\linewidth]{figures/regular_pent.png}
\end{subfigure}%
\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{figures/regular_pent_bvd.png}
\end{subfigure}
% }\\
\caption{The bounce visibility diagram for the regular pentagon. }
\label{fig:regular_pent_bvd}
\end{figure}



\begin{figure}
\centering
\makebox[\linewidth][c]{%

\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.45\linewidth]{figures/limit_cycle_concave_quad.png}
\captionof{figure}{\label{fig:limit_cycle}}
\end{subfigure}
\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.52\linewidth]{figures/concave_quad.png}
\captionof{figure}{\label{fig:color_concave_quad}}
\end{subfigure}
}

\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{figures/limit_cycle_bvd.png}
\captionof{figure}{\label{fig:concave_quad_bvd}}
\end{subfigure}%
\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.8\linewidth]{figures/limit_cycle_graph.png}
\captionof{figure}{\label{fig:limit_cycle_diagram}}
\end{subfigure}
\caption{The bounce visibility diagram with limit cycle information}
\label{fig:limit_cycle_bvd}
\end{figure}

\subsection{Combinatorial Complexity of BVD}

To consider the size of the bounce visibility diagram for an input polygon $P$
with $n$ vertices, we let $r$ be the number of reflex vertices in the polygon,
and $m$ be the average number of visible vertices to a vertex in $P'$. For a
convex vertex, its partial local sequence will not have new vertex that is not
in $P$, while for a reflex vertex, we can have $O(n)$ new vertices. We can have
as many as half of the vertices to be reflex, so $r = O(n)$; each of the reflex
vertices can produce $O(n)$ new vertices in its partial local sequence, so the
size of $P'$ is $O(n^2)$. It is possible for a vertex in $P'$ to see all other
vertex, so, in the worse case, $m = O(n^2)$. Therefore, the complexity of the
bounce visibility diagram is $O(n\cdot r\cdot m) = O(n^4)$.

We might hope that if $r$ is large, then not all of the reflex vertices will
produce a large number of new vertices, or that if there are many new vertices,
then the new vertices will not have good visibility in $P'$ since most of them
will be inserted into a corner of the polygon, and then we can bound the
complexity of the BVD. Unfortunately, the number of reflex vertices, the new
vertices produced in their partial local sequence, and the new vertices'
visibility can be large at the same time. We will present a family of input
polygons with BVD of $O(n^4)$ complexity as follows.

\begin{figure}
%\hspace{-40px}
\centering
%\makebox[\linewidth][c]{%
%\hspace{30px}
\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.7\linewidth]{figures/chestnut_5.png}
\label{fig:t4}
\end{subfigure}
%\hspace{-40px}

\begin{subfigure}{0.25\textwidth}
\centering
\includegraphics[width=0.7\linewidth]{figures/chestnut_7.png}
\label{fig:t6}
\end{subfigure}\\
\caption{The worse case polygon for $t = 4$ and $t = 6$ 
\label{fig:chestnut}}
\end{figure}

Let $n = 4t+2$, where $t$ is a positive integer. We design a polygon with
$r = 2t$ reflex vertices. The polygon is symmetric with respect to its medium
horizontal line. In the top half, the reflex vertices are uniformly located on a
circle and thus they are visible to each other; the convex vertices are chosen
so that they are outside the circle and the line through an edge will not
intersect other edges. Each reflex vertices will have at least $t-1$ new
vertices in its partial local sequence. All vertices in the top half can see
each vertex in the bottom half and vice versa. So there will be $2t(t-1)+n$
vertices in the polygon after we insert all new vertices in the partial local
sequence for all reflex vertices. Each of them can see at least $t(t-1)+n/2$
other vertices. The final complexity for the bounce visibility diagram is
$\Theta ((2t(t-1)+n)(t(t-1)+n/2)) = \Theta (t^4) = \Theta(n^4)$.
Fig \ref{fig:chestnut} shows the polygons for $t = 4$ and $t=6$ with all the
vertices in the partial local sequences. % show the diagram to edge

% show the fix bounce
% show the periodic behavior
% show the gap navigation
% show we could find equivalent class on theta
% \begin{itemize}
% \item Big O complexity of construction, and size of resulting graph


\section{BVD as an Information Space \label{bvd_info}}

Information spaces \cite{tovar2005information} are a useful formalism for
reasoning about the information available to a robot as a result of its sensor
and action history. From the \emph{history information space} (the space of all
sensor/action histories), we can define mappings to other, more useful spaces.

Here we will show that the bounce visibility diagram can induce a useful
information space for many mobile robot tasks, and can be augmented with
information from the geometric properties of actuators and sensors.

We will construct $G_{BVD}$, a graph where nodes are segments in the decomposed
environment $P'$ constructed in Section \ref{bvd_def}.

We then define edges in this graph to be transitions between these segments, based on the bounce laws and
required to transition between them. First, we observe that any two segments in
$P'$ that are visible at all are visible along their entire lengths. Thus, we
there exists a function $f$ which maps a point $s \in v_i
v_{i+1}$ to a point $f(s) \in v_j v_{j+1}$ under a bounce at angle $\theta$ from
the normal on edge $v_i v_{i+1}$, for all valid ranges of $s$, $f(s)$, and
$\theta$.

Rather than use $f$ directly, we take a nondeterministic approach and define a
directed transition between edges $v_i v_{i+1}$ and $v_j v_{j+1}$ if it is
possible to reach edge $v_j v_{j+1}$ from edge $v_i v_{i+1}$ under any bounce.
We label the edge with the range of bounce angles, $\theta_{min} < \theta <
\theta_{max}$, under which this is possible. See Figure \ref{fig:bounce_range} for
the geometric definitions of $\theta_{max}$ and $\theta_{min}$.

\begin{figure}
    \includegraphics[width=0.8\linewidth]{figures/bouncerange.png}
    \centering
    \caption{Definitions of $\theta_{max}$ and $\theta_{min}$. Can be computed
by rotating the source edge to the x axis without loss of generality.}\label{fig:bounce_range}
    \centering
\end{figure}

\subsection{Augmenting the Graph with Dynamical Information}

We can also add information to the edges in $G_{BVD}$ indicating whether the
mapping from one edge to another is a \emph{contraction mapping}: a transition
which will bring two separate points in the domain closer together in the range,
a useful property for reducing state uncertainty and engineering limit cycles,
as will be discussed in Section \ref{patrol}.

The necessary condition for $f$ to be a contraction mapping is:

\begin{equation*}
|f(x) - f(y)| \leq c |x-y|
\end{equation*}

such that $0 \leq c < 1$.

From Figure \ref{fig:cont_map}, we can see that

\begin{equation*}
|f(x) - f(y)| = \frac{\sin(\theta - \phi)}{\sin(\pi-\theta)} |x-y|
\end{equation*}

from the law of sines, where $\phi$ is the angle between the two edges if they
are extended to their intersection point. If the edges are parallel, a
contraction map is not possible (points will maintain their distance, not shrink
closer together). Thus, whenever $\frac{\sin(\theta - \phi)}{\sin(\pi-\theta)}
< 1$, $f$ is a contraction map, and the edge from $v_i v_{i+1}$ to $v_j
v_{j+1}$ can be labelled as such, with the range of $\theta$ which makes this
condition true.

Furthermore, the contraction property of a composition of multiple bounces can
be determined by simply multiplying the coefficients $\frac{\sin(\theta_i -
\phi_i)}{\sin(\pi-\theta_i)}$, and the constraints on the satisfying angles
$\theta_i$ can be propagated through the composition.

\begin{figure}
    \includegraphics[width=0.8\linewidth]{figures/contraction_map_cond.png}
    \centering
    \caption{\label{fig:cont_map}}
    \centering
\end{figure}

\subsection{Sensor Modelling}

Here we sketch how different virtual sensors may be incorporated into this
information space representation.

\begin{itemize}
\item \emph{Laser Beams:} laser beams form new, internal edges of the polygon. They can be
added to the bounce visibility graph by marking all the edges which represent
bounces that would cross the laser beam with a special symbol. different symbols
for distinguishable beams. If a beam is encountered, and we are tracking state
as a set of possible segments along the boundary of $P'$, we can reduce
uncertainty in our estimate by only propagating the state estimate
forward along edges with that symbol. To engineer reduction in uncertainty,
we may be able to put laser beams in positions that break graph symmetry.
\item \emph{Pebbles:} pebbles are quite important in many robotic tasks, such as
when we need to guarantee that a wall-following strategy has successfully
circumnavigated a polygon. In this representation, we can simply augment nodes
in $G_{BVE}$ if our robot has placed a pebble in that segment (or we may mark
multiple nodes, then use actions to reduce uncertainty in our state estimate
once we return to the pebble).
\item \emph{Cameras:} Especially when discussing coverage, it is helpful to have
some sense of how we "cover" a polygon's interior. One abstract sensor with this
behavior is a model of a camera, which may have some given range and field of
view. The set-theoretic representation of this visibility region can be used to
represent how much of the polygon may be covered by a given trajectory. Ideally,
coverage strategies would allow for satisfying coverage given nondeterminism in
the start states and actions.
\end{itemize}

\section{Task Formulation}

We will now show how to formulate many common robot task specifications in terms
of the data structure described above. The discretization of the continuous
environment allows us to now reason over trajectories through a graph.


\subsection{Navigation}

Here, we define the \emph{navigation} task as:

\begin{quotation}
Given an environment $P$, a start set of possible robot positions along the
environment boundary $S$, and a goal set $G$, determine a strategy $\pi$ which
will be guaranteed to take the robot from any point in $S$ to a point in $G$.
\end{quotation}

If the start set $S$ is such that it is equal to one of the equivalence
classes of the data structure, a navigation query is simple - the start set in
the graph is a single node, and the query is solved by a shortest path from this
node to the nodes representing the goal set. The shortest path will correspond
to the navigation strategy with the fewest number of bounces. It would also be
possible to determine the shortest path in the metric space of the polygonal
environment, either by adding weights to the edges in the graph, or by
leveraging results from shortest path navigation using visibility diagrams.

It may be
interesting to instead look to solve the navigation problem with different
criteria than the smallest number of bounces - for instance, we may look for a
strategy which uses the fewest number of bounce angles, or has the fewest number
of switches between bounce angles (especially useful for a robot which changes
its bounce angle mechanically).

If the start set $S$ lies in more than node of the graph, things get a bit
trickier. We need to guarantee all-path reachability for a set of start nodes in
a graph. There are also complications if the user-specified start set does not
exactly overlap the equivalence classes formed by the decomposition in Section
\ref{bvd_def}. For now, we can only guarantee navigation from one equivalence
class (segment along the new polygon $P'$) to another.



\subsection{Patrolling \label{patrol}}

We define the \emph{patrolling} task as:

\begin{quotation}
Given an environment $P$, a set of possible starting states $S$, and
a sequence of edges of the environment $E = \{e_1, \ldots, e_k\}$,
determine a strategy which causes the robot to visit each edge of the sequence
in order on a repeatable path.
\end{quotation}

This task is related to the Aquarium Keeper's Problem in computational
geometry \cite{czyzowicz1991aquarium}.

In prior work \cite{NilBecLav17}, it was shown that stable limit cycles
exist for constant-angle fixed bouncing in regular polygons, for some ranges of bounce angles.
These results also hold for convex polygons in general.

The general flavor of these results are that the bounce functions from edge to
edge are composed into one function which returns the robot to its starting
edge. If this function is a contraction map, a fixed point exists on the
starting edge, and thus a limit cycle of the robot's trajectory exists. The
exact conditions of the existence of this limit cycle depend on the product of
the contraction coefficients being less than one; and on $\theta$ being such
that the bounce at each stage can actually occur. All of the information
necessary to check these conditions is in $G_{BVD}$, as described in Section
\ref{bvd_info}.

Thus, finding all possible limit cycles in an environment $P$ amounts to finding
all cycles in $G_{BVD}$ such that this condition holds.

To examine the behavior of a robot with a given fixed bounce angle, such as the
analysis in \cite{ErLav13}, we can easily extract information for the fixed angle bouncing strategy
mentioned in section \ref{subsec:bounce_strategy} by overlaying an horizontal
line $\theta = \theta_0$ onto the BVD, where $\theta_0$ is the angle chosen by
the bouncing strategy. In Fig \ref{fig:limit_cycle_bvd}, one of the possible
limit cycle with fixed angle $\theta = 0.6$ for the concave quadrilateral is
shown in Fig \ref{fig:limit_cycle}; the bounce visibility diagram for this
polygon is shown in Fig \ref{fig:concave_quad_bvd} with the horizontal line
$\theta = \theta_0$, where $\theta_0 = \frac{\pi}{2}-0.6$ (we need to convert
the angle from w.r.t the normal of the wall to w.r.t the forward direction of
the robot). The horizontal line cut through different regions of the diagram,
representing the possible edges that the robot can bounce to at different points
on the boundary with bounce angle $\theta_0$. For example, at edge $v_5v_0$, the
robot can bounce to edge $v_0v_1$ and $v_1v_2$. We can create a graph for
$\theta = \theta_0$, whose nodes are edges in $P'$ and two nodes are connected
by a directed edge if the robot can bounce from one edge to another at
$\theta_0$, as shown in Fig \ref{fig:limit_cycle_diagram}. It is more stable
for the robot to bounce to some edges than others. In the diagram
(Fig \ref{fig:concave_quad_bvd}), the line $\theta = \theta_0$ cuts through
four different regions for $x \in (2, 3)$, but the sections for $v_4v_5$ and
$v_0v_5$ are much larger than those for $v_0v_1$ and $v_1v_2$. So we know it is
more likely and more stable for the robot to bounce to edge $v_4v_5$ and
$v_0v_5$. We marked the edge with unstable bounce in the graph with $\omega$ in
Fig \ref{fig:limit_cycle_diagram}. The limit cycle shown in
Fig \ref{fig:limit_cycle} corresponds to the cycle
$v_0v_1\rightarrow v_3v_4\rightarrow v_4v_5 \rightarrow v_1v_2 \rightarrow v_2v_3 \rightarrow v_0v_5 \rightarrow v_0v_1$
in Fig \ref{fig:limit_cycle_diagram}.


\begin{figure}
\centering
\begin{subfigure}{0.3\textwidth}
  \includegraphics[width=\linewidth]{figures/simple_nonconv_augmented.png}
  \label{fig:sn1}
\end{subfigure}%
\begin{subfigure}{0.3\textwidth}
  \includegraphics[width=\linewidth]{figures/simple_nonconv_BVD.png}
  \label{fig:sn2}
\end{subfigure}%
\begin{subfigure}{0.3\textwidth}
  \includegraphics[width=\linewidth]{figures/simple_nonconv.jpg}
  \label{fig:sn3}
\end{subfigure}
\caption{\label{fig:sn}}

\end{figure}


\subsection{Localization}

We define the \emph{localization} task as:

\begin{quotation}
Given an accurate map of the environment, but no knowledge of configuration,
determine a strategy which eliminates uncertainty in configuration as much as
possible (ideally, to a point in configuration space).
\end{quotation}

In \cite{OkaLav06}, the authors show that localization is possible with
mobile robots with a linear and angular odometer, or a compass and contact
sensor, but not with robots with only an angular odometer and contact sensor.
These sensing configurations correspond to which types of bounce laws each robot
is capable of performing, and we would like to be able to rederive the same
results in this representation.

Localization amounts to a path finding algorithm in the larger graph, where each
node is an element of the powerset of segments along $P'$. Future work will
include how to tractibly search this graph (such as heuristics for doing so
which take advantage of the uncertainty-reducing properties of contraction
mappings).


\section{Open Questions and Future Work}

Future work also includes:

\begin{itemize}
\item Characterizing the completeness and correctness of algorithms for
navigation, coverage, localization, etc.
\item Continue to place this work in context, especially with BitBots, Gap
Navigation Trees, and Combinatorial Visibility Vectors
\item Developing ways to query two $G_{BVD}$s, generated with different constraints on
 bouncing laws and sensors, and determine whether one represents a robot which
is ``more powerful" than another. Perhaps this will require a clever
parameterization of bouncing laws.
\item Investigate how to generate bounce law distributions that allow a bounce
to be randomly selected at each stage and guarantee some properties about the
resulting trajectory
\item Extending analysis to more tasks, such as coverage and pursuit-evasion
\end{itemize}




\fi

\bibliographystyle{IEEEtran}
\bibliography{refs}
\end{document}
